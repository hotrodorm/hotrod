package org.hotrod.metadata;

import java.io.Serializable;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.hotrod.ant.ControlledException;
import org.hotrod.ant.UncontrolledException;
import org.hotrod.config.AbstractDAOTag;
import org.hotrod.config.AutoGeneratedColumnTag;
import org.hotrod.config.ColumnTag;
import org.hotrod.config.EnumTag;
import org.hotrod.config.HotRodConfigTag;
import org.hotrod.config.HotRodFragmentConfigTag;
import org.hotrod.config.QueryMethodTag;
import org.hotrod.config.SelectGenerationTag;
import org.hotrod.config.SelectMethodTag;
import org.hotrod.config.SequenceMethodTag;
import org.hotrod.config.TableTag;
import org.hotrod.config.VersionControlColumnTag;
import org.hotrod.config.ViewTag;
import org.hotrod.database.DatabaseAdapter;
import org.hotrod.exceptions.InvalidConfigurationFileException;
import org.hotrod.exceptions.UnresolvableDataTypeException;
import org.hotrod.generator.HotRodGenerator;
import org.hotrod.generator.ParameterRenderer;
import org.hotrod.generator.SelectMetadataCache;
import org.hotrod.generator.mybatis.DataSetLayout;
import org.hotrod.utils.ClassPackage;
import org.hotrod.utils.ColumnsPrefixGenerator;
import org.hotrod.utils.identifiers.DataSetIdentifier;
import org.hotrod.utils.identifiers.Identifier;
import org.nocrala.tools.database.tartarus.core.JdbcColumn;
import org.nocrala.tools.database.tartarus.core.JdbcForeignKey;
import org.nocrala.tools.database.tartarus.core.JdbcKey;
import org.nocrala.tools.database.tartarus.core.JdbcKeyColumn;
import org.nocrala.tools.database.tartarus.core.JdbcTable;

public class TableDataSetMetadata implements DataSetMetadata, Serializable {

  private static final long serialVersionUID = 1L;

  private static final Logger log = Logger.getLogger(TableDataSetMetadata.class);

  protected transient JdbcTable t;
  protected transient HotRodConfigTag config;
  protected transient DatabaseAdapter adapter;

  private AbstractDAOTag daoTag;

  private List<ColumnMetadata> cols;
  private KeyMetadata pk;
  private List<KeyMetadata> uniqueIndexes;
  private List<ColumnMetadata> nonPKCols;
  private List<ForeignKeyMetadata> importedFKs;
  private List<ForeignKeyMetadata> exportedFKs;

  private String javaName;

  private AutoGeneratedColumnMetadata agcm;
  private VersionControlMetadata vcm;

  private List<SequenceMethodTag> sequences = new ArrayList<SequenceMethodTag>();
  private List<QueryMethodTag> queries = new ArrayList<QueryMethodTag>();
  private List<SelectMethodTag> selects = new ArrayList<SelectMethodTag>();

  private SelectMetadataCache selectMetadataCache;
  private List<SelectMethodMetadata> selectsMetadata;

  private HotRodFragmentConfigTag fragmentConfig;

  @SuppressWarnings("unused")
  private ClassPackage classPackage;

  // Table constructor

  protected TableDataSetMetadata(final TableTag tableTag, final JdbcTable t, final DatabaseAdapter adapter,
      final HotRodConfigTag config, final DataSetLayout layout, final SelectMetadataCache selectMetadataCache)
      throws UnresolvableDataTypeException, ControlledException {
    this.t = t;
    this.config = config;
    this.adapter = adapter;

    this.daoTag = tableTag;
    this.fragmentConfig = tableTag.getFragmentConfig();

    this.selectMetadataCache = selectMetadataCache;

    ClassPackage fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage() : null;
    this.classPackage = layout.getDAOPrimitivePackage(fragmentPackage);

    this.cols = getColumnsMetadata(this.t.getColumns(), tableTag);
    this.pk = getKeyMetadata(this.t.getPk(), tableTag);

    this.uniqueIndexes = new ArrayList<KeyMetadata>();
    for (JdbcKey k : this.t.getUniqueIndexes()) {
      this.uniqueIndexes.add(getKeyMetadata(k, tableTag));
    }

    this.importedFKs = new ArrayList<ForeignKeyMetadata>();
    for (JdbcForeignKey fk : this.t.getImportedFks()) {
      KeyMetadata ikm;
      TableTag remoteTableTag = this.config.getTableTag(fk.getRemoteTable());
      if (remoteTableTag != null) {
        ikm = getKeyMetadata(fk.getRemoteKey(), remoteTableTag);
      } else {
        EnumTag remoteEnumTag = this.config.getEnumTag(fk.getRemoteTable());
        if (remoteEnumTag != null) {
          ikm = getKeyMetadata(fk.getRemoteKey(), remoteEnumTag);
        } else {
          throw new RuntimeException(
              "Could not find the remote table or enum for the imported FK on table=" + t.getName());
        }
      }
      this.importedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), tableTag), ikm, fk.pointsToPk(),
          fk.getRemoteTable()));
    }

    this.exportedFKs = new ArrayList<ForeignKeyMetadata>();
    for (JdbcForeignKey fk : this.t.getExportedFks()) {
      KeyMetadata ekm;
      TableTag remoteTableTag = this.config.getTableTag(fk.getRemoteTable());
      if (remoteTableTag != null) {
        ekm = getKeyMetadata(fk.getRemoteKey(), remoteTableTag);
      } else {
        EnumTag remoteEnumTag = this.config.getEnumTag(fk.getRemoteTable());
        if (remoteEnumTag != null) {
          ekm = getKeyMetadata(fk.getRemoteKey(), remoteEnumTag);
        } else {
          throw new RuntimeException(
              "Could not find the remote table or enum for the imported FK on table=" + t.getName());
        }
      }
      this.exportedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), tableTag), ekm, fk.pointsToPk(),
          fk.getRemoteTable()));
    }

    this.nonPKCols = getColumnsMetadata(this.t.getNonPkColumns(), tableTag);

    this.javaName = tableTag.getJavaName();
    // log.info("this.javaName=" + this.javaName);

    AutoGeneratedColumnTag agct = tableTag.getAutoGeneratedColumn();
    if (agct == null) { // no auto-generated column
      this.agcm = null;
    } else { // there is an auto-generated column
      this.agcm = new AutoGeneratedColumnMetadata(this, agct, this.adapter);
    }

    VersionControlColumnTag vct = tableTag.getVersionControlColumn();
    if (vct == null) {
      this.vcm = null;
    } else {
      ColumnMetadata vcm = this.findColumnMetadata(vct);
      if (vcm == null) {
        throw new ControlledException(
            "Could not find version control column with name '" + vct.getName() + "' on table '" + t.getName() + "'.");
      }
      vcm.setVersionControlColumn(true);
      this.vcm = new VersionControlMetadata(this, vct, vcm, this.adapter);
    }

    this.sequences = tableTag.getSequences();
    this.queries = tableTag.getQueries();
    this.selects = tableTag.getSelects();

  }

  // Enum Constructor

  protected TableDataSetMetadata(final EnumTag enumTag, final JdbcTable t, final DatabaseAdapter adapter,
      final HotRodConfigTag config, final DataSetLayout layout, final SelectMetadataCache selectMetadataCache)
      throws UnresolvableDataTypeException, ControlledException {
    this.t = t;
    this.config = config;
    this.adapter = adapter;

    this.daoTag = enumTag;
    this.fragmentConfig = enumTag.getFragmentConfig();

    this.selectMetadataCache = selectMetadataCache;

    ClassPackage fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage() : null;
    this.classPackage = layout.getDAOPrimitivePackage(fragmentPackage);

    this.cols = getColumnsMetadata(this.t.getColumns(), enumTag);
    this.pk = null;

    this.uniqueIndexes = new ArrayList<KeyMetadata>();
    this.importedFKs = new ArrayList<ForeignKeyMetadata>();
    this.exportedFKs = new ArrayList<ForeignKeyMetadata>();

    this.nonPKCols = getColumnsMetadata(this.t.getNonPkColumns(), enumTag);

    this.agcm = null;

    this.vcm = null;

    this.sequences = enumTag.getSequences();
    this.queries = enumTag.getQueries();

  }

  // View Constructor

  protected TableDataSetMetadata(final ViewTag viewTag, final JdbcTable t, final DatabaseAdapter adapter,
      final HotRodConfigTag config, final DataSetLayout layout, final SelectMetadataCache selectMetadataCache)
      throws UnresolvableDataTypeException, ControlledException {

    this.t = t;
    this.config = config;
    this.adapter = adapter;

    this.daoTag = viewTag;
    this.fragmentConfig = viewTag.getFragmentConfig();

    this.selectMetadataCache = selectMetadataCache;

    ClassPackage fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage() : null;
    this.classPackage = layout.getDAOPrimitivePackage(fragmentPackage);

    this.cols = getColumnsMetadata(this.t.getColumns(), viewTag);
    this.pk = null;

    this.uniqueIndexes = new ArrayList<KeyMetadata>();
    for (JdbcKey k : this.t.getUniqueIndexes()) {
      this.uniqueIndexes.add(getKeyMetadata(k, viewTag));
    }

    this.importedFKs = new ArrayList<ForeignKeyMetadata>();
    for (JdbcForeignKey fk : this.t.getImportedFks()) {
      this.importedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), viewTag),
          getKeyMetadata(fk.getRemoteKey(), viewTag), fk.pointsToPk(), fk.getRemoteTable()));
    }

    this.exportedFKs = new ArrayList<ForeignKeyMetadata>();
    for (JdbcForeignKey fk : this.t.getExportedFks()) {
      this.exportedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), viewTag),
          getKeyMetadata(fk.getRemoteKey(), viewTag), fk.pointsToPk(), fk.getRemoteTable()));
    }

    this.nonPKCols = getColumnsMetadata(this.t.getNonPkColumns(), viewTag);

    this.javaName = viewTag.getJavaName();
    this.agcm = null;
    this.vcm = null;

    this.sequences = viewTag.getSequences();
    this.queries = viewTag.getQueries();
    this.selects = viewTag.getSelects();

  }

  public void linkReferencedTableMetadata(final Set<TableDataSetMetadata> dss) {
    for (ForeignKeyMetadata fk : this.importedFKs) {
      fk.linkReferencedTableMetadata(dss);
    }
    for (ForeignKeyMetadata fk : this.exportedFKs) {
      fk.linkReferencedTableMetadata(dss);
    }
  }

  public void linkEnumMetadata(final Set<EnumDataSetMetadata> enums) {
    for (ForeignKeyMetadata ifk : this.importedFKs) {
      try {
        EnumDataSetMetadata em = (EnumDataSetMetadata) ifk.getRemote().getTableMetadata();
        for (ColumnMetadata icm : ifk.getLocal().getColumns()) {
          icm.setEnumMetadata(em);
          for (ColumnMetadata cm : this.cols) {
            if (cm.getColumnName().equals(icm.getColumnName())) {
              cm.setEnumMetadata(em);
            }
          }
          for (ColumnMetadata cm : this.pk.getColumns()) {
            if (cm.getColumnName().equals(icm.getColumnName())) {
              cm.setEnumMetadata(em);
            }
          }
          for (ColumnMetadata cm : this.nonPKCols) {
            if (cm.getColumnName().equals(icm.getColumnName())) {
              cm.setEnumMetadata(em);
            }
          }
        }
      } catch (ClassCastException e) {
        // FK does not point to an enum - nothing to do.
      }
    }
  }

  // Select Methods meta data gathering

  public boolean gatherSelectsMetadataPhase1(final HotRodGenerator generator, final Connection conn1,
      final DataSetLayout layout) throws ControlledException, UncontrolledException {
    this.selectsMetadata = new ArrayList<SelectMethodMetadata>();
    boolean needsToRetrieveMetadata = false;
    for (SelectMethodTag selectTag : this.selects) {
      log.info(
          ">>> [" + this.getIdentifier().getSQLIdentifier() + "] this.selectMetadataCache=" + this.selectMetadataCache);
      SelectMethodMetadata cachedSm = this.selectMetadataCache.get(this.javaName, selectTag.getMethod());

      if (referencesAMarkedEntity(selectTag.getReferencedEntities())) {
        selectTag.markGenerate();
      }

      if (cachedSm != null && !selectTag.isToBeGenerated()) {

        // use the cached metadata
        this.selectsMetadata.add(cachedSm);

      } else {

        // retrieve fresh metadata
        needsToRetrieveMetadata = true;
        SelectGenerationTag selectGenerationTag = this.config.getGenerators().getSelectedGeneratorTag()
            .getSelectGeneration();
        ColumnsPrefixGenerator columnsPrefixGenerator = new ColumnsPrefixGenerator(this.adapter.getUnescapedSQLCase());
        SelectMethodMetadata sm = new SelectMethodMetadata(generator, selectTag, this.config, selectGenerationTag,
            columnsPrefixGenerator, layout);
        this.selectsMetadata.add(sm);
        sm.gatherMetadataPhase1(conn1);

      }
    }
    return needsToRetrieveMetadata;
  }

  private boolean referencesAMarkedEntity(final Set<TableDataSetMetadata> referencedEntities) {
    for (TableDataSetMetadata referencedEntity : referencedEntities) {
      if (referencedEntity.getDaoTag().isToBeGenerated()) {
        return true;
      }
    }
    return false;
  }

  public void gatherSelectsMetadataPhase2(final Connection conn2, final VORegistry voRegistry)
      throws ControlledException, UncontrolledException, InvalidConfigurationFileException {
    log.info("*** DataSet " + this.renderSQLIdentifier() + ":");
    for (SelectMethodMetadata sm : this.selectsMetadata) {
      log.info("*** - method " + sm.getMethod() + "() sm.metadataComplete()=" + sm.metadataComplete());
      if (!sm.metadataComplete()) {
        log.debug("... method: " + sm.getMethod());
        sm.gatherMetadataPhase2(conn2, voRegistry);
      }
    }
  }

  // Utilities

  private List<ColumnMetadata> getColumnsMetadata(final List<JdbcColumn> cols, final TableTag tableTag)
      throws UnresolvableDataTypeException {
    List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
    for (JdbcColumn c : cols) {
      boolean belongsToPK = this.t.getPk() != null && keyIncludesColumn(this.t.getPk(), c);
      ColumnTag columnTag = tableTag.findColumnTag(c.getName(), this.adapter);
      lcm.add(new ColumnMetadata(this, c, this.adapter, columnTag, false, belongsToPK));
    }
    return lcm;
  }

  private List<ColumnMetadata> getColumnsMetadata(final List<JdbcColumn> cols, final EnumTag enumTag)
      throws UnresolvableDataTypeException {
    List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
    for (JdbcColumn c : cols) {
      boolean belongsToPK = this.t.getPk() != null && keyIncludesColumn(this.t.getPk(), c);
      ColumnTag columnTag = enumTag.findColumnTag(c.getName(), this.adapter);
      lcm.add(new ColumnMetadata(this, c, this.adapter, columnTag, false, belongsToPK));
    }
    return lcm;
  }

  private List<ColumnMetadata> getColumnsMetadata(final List<JdbcColumn> cols, final ViewTag viewTag)
      throws UnresolvableDataTypeException {
    List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
    for (JdbcColumn c : cols) {
      ColumnTag columnTag = viewTag.findColumnTag(c.getName(), this.adapter);
      lcm.add(new ColumnMetadata(this, c, this.adapter, columnTag, false, false));
    }
    return lcm;
  }

  private KeyMetadata getKeyMetadata(final JdbcKey kc, final TableTag tableTag) throws UnresolvableDataTypeException {
    if (kc == null) {
      return null;
    } else {
      List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
      for (JdbcKeyColumn c : kc.getKeyColumns()) {
        boolean belongsToPK = this.t.getPk() != null && keyIncludesColumn(this.t.getPk(), c.getColumn());
        ColumnTag columnTag = tableTag.findColumnTag(c.getColumn().getName(), this.adapter);
        lcm.add(new ColumnMetadata(this, c.getColumn(), this.adapter, columnTag, false, belongsToPK));
      }
      return new KeyMetadata(this, lcm);
    }
  }

  private KeyMetadata getKeyMetadata(final JdbcKey kc, final EnumTag enumTag) throws UnresolvableDataTypeException {
    if (kc == null) {
      return null;
    } else {
      List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
      for (JdbcKeyColumn c : kc.getKeyColumns()) {
        boolean belongsToPK = this.t.getPk() != null && keyIncludesColumn(this.t.getPk(), c.getColumn());
        ColumnTag columnTag = enumTag.findColumnTag(c.getColumn().getName(), this.adapter);
        lcm.add(new ColumnMetadata(this, c.getColumn(), this.adapter, columnTag, false, belongsToPK));
      }
      return new KeyMetadata(this, lcm);
    }
  }

  private KeyMetadata getKeyMetadata(final JdbcKey kc, final ViewTag viewTag) throws UnresolvableDataTypeException {
    if (kc == null) {
      return null;
    } else {
      List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
      for (JdbcKeyColumn c : kc.getKeyColumns()) {
        ColumnTag columnTag = viewTag.findColumnTag(c.getColumn().getName(), this.adapter);
        lcm.add(new ColumnMetadata(this, c.getColumn(), this.adapter, columnTag, false, false));
      }
      return new KeyMetadata(this, lcm);
    }
  }

  private boolean keyIncludesColumn(final JdbcKey key, final JdbcColumn c) {
    for (JdbcKeyColumn kc : key.getKeyColumns()) {
      if (kc.getColumn().getName().equals(c.getName())) {
        return true;
      }
    }
    return false;
  }

  private ColumnMetadata findColumnMetadata(final VersionControlColumnTag vct) {
    for (ColumnMetadata m : this.cols) {
      if (this.adapter.isColumnIdentifier(m.getColumnName(), vct.getName())) {
        return m;
      }
    }
    return null;
  }

  // Indexable

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((this.t.getName() == null) ? 0 : this.t.getName().hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    TableDataSetMetadata other = (TableDataSetMetadata) obj;
    if (this.t.getName() == null) {
      if (other.t.getName() != null)
        return false;
    } else if (!this.t.getName().equals(other.t.getName()))
      return false;
    return true;
  }

  boolean correspondsToJdbcTable(final JdbcTable t) {
    return this.t.getName().equals(t.getName());
  }

  // Getters

  @Override
  public List<SelectMethodMetadata> getSelectsMetadata() {
    return selectsMetadata;
  }

  @Override
  public AbstractDAOTag getDaoTag() {
    return daoTag;
  }

  @Override
  public List<ColumnMetadata> getColumns() {
    return cols;
  }

  @Override
  public List<ColumnMetadata> getNonPkColumns() {
    return this.nonPKCols;
  }

  @Override
  public KeyMetadata getPK() {
    return this.pk;
  }

  @Override
  public DataSetIdentifier getIdentifier() {
    // log.info("this.t.getName()=" + this.t.getName() + " this.javaName=" +
    // this.javaName);
    if (this.javaName == null) {
      return new DataSetIdentifier(this.t.getName());
    } else {
      return new DataSetIdentifier(this.t.getName(), this.javaName);
    }
  }

  @Override
  public List<KeyMetadata> getUniqueIndexes() {
    return this.uniqueIndexes;
  }

  @Override
  public List<ForeignKeyMetadata> getImportedFKs() {
    return this.importedFKs;
  }

  @Override
  public List<ForeignKeyMetadata> getExportedFKs() {
    return this.exportedFKs;
  }

  @Override
  public List<SelectParameterMetadata> getParameters() {
    return new ArrayList<SelectParameterMetadata>();
  }

  @Override
  public List<SelectParameterMetadata> getParameterDefinitions() {
    return new ArrayList<SelectParameterMetadata>();
  }

  @Override
  public String renderSQLSentence(final ParameterRenderer parameterRenderer) {
    return null;
  }

  @Override
  public String renderXML(final ParameterRenderer parameterRenderer) {
    return null;
  }

  @Override
  public AutoGeneratedColumnMetadata getAutoGeneratedColumnMetadata() {
    return this.agcm;
  }

  @Override
  public VersionControlMetadata getVersionControlMetadata() {
    return this.vcm;
  }

  @Override
  @Deprecated
  public String generateDAOName(final Identifier identifier) {
    return this.config.getGenerators().getSelectedGeneratorTag().getDaos().generateDAOName(identifier);
  }

  @Override
  @Deprecated
  public String generatePrimitivesName(final Identifier identifier) {
    log.debug("identifier.getJavaClassIdentifier()=" + identifier.getJavaClassIdentifier());
    return this.config.getGenerators().getSelectedGeneratorTag().getDaos().generatePrimitivesName(identifier);
  }

  public List<SequenceMethodTag> getSequences() {
    return sequences;
  }

  public List<QueryMethodTag> getQueries() {
    return queries;
  }

  public boolean hasSelects() {
    return !this.selects.isEmpty();
  }

  @Override
  public String renderSQLIdentifier() {
    return this.adapter.renderSQLName(t.getName());
  }

  @Override
  public HotRodFragmentConfigTag getFragmentConfig() {
    return this.fragmentConfig;
  }

}
