package org.hotrod.metadata;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.hotrod.ant.ControlledException;
import org.hotrod.config.AbstractDAOTag;
import org.hotrod.config.AutoGeneratedColumnTag;
import org.hotrod.config.ColumnTag;
import org.hotrod.config.HotRodConfigTag;
import org.hotrod.config.QueryTag;
import org.hotrod.config.SequenceTag;
import org.hotrod.config.TableTag;
import org.hotrod.config.VersionControlColumnTag;
import org.hotrod.config.ViewTag;
import org.hotrod.database.DatabaseAdapter;
import org.hotrod.exceptions.AutogeneratedKeysNotSupportedException;
import org.hotrod.exceptions.UnresolvableDataTypeException;
import org.hotrod.generator.ParameterRenderer;
import org.hotrod.utils.identifiers.DataSetIdentifier;
import org.hotrod.utils.identifiers.Identifier;
import org.nocrala.tools.database.tartarus.core.JdbcColumn;
import org.nocrala.tools.database.tartarus.core.JdbcForeignKey;
import org.nocrala.tools.database.tartarus.core.JdbcKey;
import org.nocrala.tools.database.tartarus.core.JdbcKeyColumn;
import org.nocrala.tools.database.tartarus.core.JdbcTable;

public class TableDataSetMetadata implements DataSetMetadata {

  private static final Logger log = Logger.getLogger(TableDataSetMetadata.class);

  private JdbcTable t;
  private HotRodConfigTag config;
  private DatabaseAdapter adapter;

  private AbstractDAOTag daoTag;

  private List<ColumnMetadata> cols;
  private KeyMetadata pk;
  private List<KeyMetadata> uniqueIndexes;
  private List<ColumnMetadata> nonPKCols;
  private List<ForeignKeyMetadata> importedFKs;
  private List<ForeignKeyMetadata> exportedFKs;

  private String javaName;

  private AutoGeneratedColumnMetadata agcm;
  private VersionControlMetadata vcm;

  private List<SequenceTag> sequences = new ArrayList<SequenceTag>();
  private List<QueryTag> queries = new ArrayList<QueryTag>();

  // Constructor

  public TableDataSetMetadata(final JdbcTable t, final DatabaseAdapter adapter, final HotRodConfigTag config)
      throws UnresolvableDataTypeException, ControlledException {
    this.t = t;
    this.config = config;
    this.adapter = adapter;

    TableTag tableTag = this.config.getTableTag(this.t);
    ViewTag viewTag = this.config.getViewTag(this.t);

    if (tableTag == null && viewTag == null) {
      throw new ControlledException("Could not find table or view with name '" + t.getName() + "'.");
    }

    if (tableTag != null) {

      this.daoTag = tableTag;

      this.cols = getColumnsMetadata(this.t.getColumns(), tableTag);
      this.pk = getKeyMetadata(this.t.getPk(), tableTag);

      this.uniqueIndexes = new ArrayList<KeyMetadata>();
      for (JdbcKey k : this.t.getUniqueIndexes()) {
        this.uniqueIndexes.add(getKeyMetadata(k, tableTag));
      }

      this.importedFKs = new ArrayList<ForeignKeyMetadata>();
      for (JdbcForeignKey fk : this.t.getImportedFks()) {
        TableTag remoteTableTag = this.config.getTableTag(fk.getRemoteTable());
        if (remoteTableTag == null) {
          throw new RuntimeException("Could not find the remote table for the imported FK on table=" + t.getName());
        }
        this.importedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), tableTag),
            getKeyMetadata(fk.getRemoteKey(), remoteTableTag), fk.pointsToPk(), fk.getRemoteTable()));
      }

      this.exportedFKs = new ArrayList<ForeignKeyMetadata>();
      for (JdbcForeignKey fk : this.t.getExportedFks()) {
        TableTag remoteTableTag = this.config.getTableTag(fk.getRemoteTable());
        if (remoteTableTag == null) {
          throw new RuntimeException("Could not find the remote table for the exported FK on table=" + t.getName());
        }
        this.exportedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), tableTag),
            getKeyMetadata(fk.getRemoteKey(), remoteTableTag), fk.pointsToPk(), fk.getRemoteTable()));
      }

      this.nonPKCols = getColumnsMetadata(this.t.getNonPkColumns(), tableTag);

      this.javaName = tableTag.getJavaName();

      AutoGeneratedColumnTag agct = tableTag.getAutoGeneratedColumn();
      if (agct == null) { // no auto-generated column
        this.agcm = null;
      } else { // there is an auto-generated column
        this.agcm = new AutoGeneratedColumnMetadata(this, agct, this.adapter);
      }

      VersionControlColumnTag vct = tableTag.getVersionControlColumn();
      if (vct == null) {
        this.vcm = null;
      } else {
        ColumnMetadata vcm = this.findColumnMetadata(vct);
        if (vcm == null) {
          throw new ControlledException("Could not find version control column with name '" + vct.getName()
              + "' on table '" + t.getName() + "'.");
        }
        vcm.setVersionControlColumn(true);
        this.vcm = new VersionControlMetadata(this, vct, vcm, this.adapter);
      }

      this.sequences = tableTag.getSequences();
      this.queries = tableTag.getQueries();

    } else {

      this.daoTag = viewTag;

      this.cols = getColumnsMetadata(this.t.getColumns(), viewTag);
      this.pk = null;

      this.uniqueIndexes = new ArrayList<KeyMetadata>();
      for (JdbcKey k : this.t.getUniqueIndexes()) {
        this.uniqueIndexes.add(getKeyMetadata(k, viewTag));
      }

      this.importedFKs = new ArrayList<ForeignKeyMetadata>();
      for (JdbcForeignKey fk : this.t.getImportedFks()) {
        this.importedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), viewTag),
            getKeyMetadata(fk.getRemoteKey(), viewTag), fk.pointsToPk(), fk.getRemoteTable()));
      }

      this.exportedFKs = new ArrayList<ForeignKeyMetadata>();
      for (JdbcForeignKey fk : this.t.getExportedFks()) {
        // System.out.println(" /// " + t.getName() + " -> " +
        // fk.getRemoteTable().getName());
        this.exportedFKs.add(new ForeignKeyMetadata(getKeyMetadata(fk.getLocalKey(), viewTag),
            getKeyMetadata(fk.getRemoteKey(), viewTag), fk.pointsToPk(), fk.getRemoteTable()));
      }

      this.nonPKCols = getColumnsMetadata(this.t.getNonPkColumns(), viewTag);

      this.javaName = viewTag.getJavaName();
      this.agcm = null;
      this.vcm = null;

      this.sequences = viewTag.getSequences();
      this.queries = viewTag.getQueries();

    }

  }

  public void linkReferencedDataSets(final Set<TableDataSetMetadata> dss) {
    for (ForeignKeyMetadata fk : this.importedFKs) {
      fk.linkReferencedDataSet(dss);
    }
    for (ForeignKeyMetadata fk : this.exportedFKs) {
      fk.linkReferencedDataSet(dss);
    }
  }

  // Utilities

  private List<ColumnMetadata> getColumnsMetadata(final List<JdbcColumn> cols, final TableTag tableTag)
      throws UnresolvableDataTypeException {
    List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
    for (JdbcColumn c : cols) {
      ColumnTag columnTag = tableTag.findColumnTag(c.getName(), this.adapter);
      lcm.add(new ColumnMetadata(c, this.adapter, columnTag, false));
    }
    return lcm;
  }

  private List<ColumnMetadata> getColumnsMetadata(final List<JdbcColumn> cols, final ViewTag viewTag)
      throws UnresolvableDataTypeException {
    List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
    for (JdbcColumn c : cols) {
      ColumnTag columnTag = viewTag.findColumnTag(c.getName(), this.adapter);
      lcm.add(new ColumnMetadata(c, this.adapter, columnTag, false));
    }
    return lcm;
  }

  private KeyMetadata getKeyMetadata(final JdbcKey kc, final TableTag tableTag) throws UnresolvableDataTypeException {
    if (kc == null) {
      return null;
    } else {
      List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
      for (JdbcKeyColumn c : kc.getKeyColumns()) {
        ColumnTag columnTag = tableTag.findColumnTag(c.getColumn().getName(), this.adapter);
        lcm.add(new ColumnMetadata(c.getColumn(), this.adapter, columnTag, false));
      }
      return new KeyMetadata(this, lcm);
    }
  }

  private KeyMetadata getKeyMetadata(final JdbcKey kc, final ViewTag viewTag) throws UnresolvableDataTypeException {
    if (kc == null) {
      return null;
    } else {
      List<ColumnMetadata> lcm = new ArrayList<ColumnMetadata>();
      for (JdbcKeyColumn c : kc.getKeyColumns()) {
        ColumnTag columnTag = viewTag.findColumnTag(c.getColumn().getName(), this.adapter);
        lcm.add(new ColumnMetadata(c.getColumn(), this.adapter, columnTag, false));
      }
      return new KeyMetadata(this, lcm);
    }
  }

  private ColumnMetadata findColumnMetadata(final VersionControlColumnTag vct) {
    for (ColumnMetadata m : this.cols) {
      if (this.adapter.isColumnIdentifier(m.getColumnName(), vct.getName())) {
        return m;
      }
    }
    return null;
  }

  // Indexing methods

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((this.t.getName() == null) ? 0 : this.t.getName().hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    TableDataSetMetadata other = (TableDataSetMetadata) obj;
    if (this.t.getName() == null) {
      if (other.t.getName() != null)
        return false;
    } else if (!this.t.getName().equals(other.t.getName()))
      return false;
    return true;
  }

  boolean correspondsToJdbcTable(final JdbcTable t) {
    return this.t.getName().equals(t.getName());
  }

  // Getters

  public AbstractDAOTag getDaoTag() {
    return daoTag;
  }

  @Override
  public List<ColumnMetadata> getColumns() {
    return cols;
  }

  @Override
  public List<ColumnMetadata> getNonPkColumns() {
    return this.nonPKCols;
  }

  @Override
  public KeyMetadata getPK() {
    return this.pk;
  }

  @Override
  public DataSetIdentifier getIdentifier() {
    log.debug("this.javaName=" + this.javaName);
    if (this.javaName == null) {
      return new DataSetIdentifier(this.t.getName());
    } else {
      return new DataSetIdentifier(this.t.getName(), this.javaName);
    }
  }

  @Override
  public List<KeyMetadata> getUniqueIndexes() {
    return this.uniqueIndexes;
  }

  @Override
  public List<ForeignKeyMetadata> getImportedFKs() {
    return this.importedFKs;
  }

  @Override
  public List<ForeignKeyMetadata> getExportedFKs() {
    return this.exportedFKs;
  }

  @Override
  public List<SelectParameterMetadata> getParameters() {
    return new ArrayList<SelectParameterMetadata>();
  }

  @Override
  public List<SelectParameterMetadata> getParameterDefinitions() {
    return new ArrayList<SelectParameterMetadata>();
  }

  @Override
  public String renderSQLSentence(final ParameterRenderer parameterRenderer) {
    return null;
  }

  @Override
  public AutoGeneratedColumnMetadata getAutoGeneratedColumnMetadata() {
    return this.agcm;
  }

  @Override
  public VersionControlMetadata getVersionControlMetadata() {
    return this.vcm;
  }

  @Override
  public String getAutoGeneratedKeySentence(final AutoGeneratedColumnMetadata agcm)
      throws AutogeneratedKeysNotSupportedException {
    return this.adapter.getAutoGeneratedKeySentence(agcm);
  }

  @Override
  public String generateDAOName(final Identifier identifier) {
    return this.config.getGenerators().getSelectedGeneratorTag().getDaos().generateDAOName(identifier);
  }

  @Override
  public String generatePrimitivesName(final Identifier identifier) {
    log.debug("identifier.getJavaClassIdentifier()=" + identifier.getJavaClassIdentifier());
    return this.config.getGenerators().getSelectedGeneratorTag().getDaos().generatePrimitivesName(identifier);
  }

  public List<SequenceTag> getSequences() {
    return sequences;
  }

  public List<QueryTag> getQueries() {
    return queries;
  }

  @Override
  public String renderSQLIdentifier() {
    return this.adapter.quoteSQLName(t.getName());
  }

  @Override
  public String getAugmentedSQL() {
    return null;
  }

}
