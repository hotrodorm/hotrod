package org.hotrod.generator.mybatis;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.LinkedHashSet;
import java.util.Set;

import org.apache.log4j.Logger;
import org.hotrod.ant.ControlledException;
import org.hotrod.ant.UncontrolledException;
import org.hotrod.config.AbstractCompositeDAOTag;
import org.hotrod.config.HotRodFragmentConfigTag;
import org.hotrod.config.QueryTag;
import org.hotrod.config.SelectTag;
import org.hotrod.config.SequenceTag;
import org.hotrod.database.DatabaseAdapter;
import org.hotrod.exceptions.AutogeneratedKeysNotSupportedException;
import org.hotrod.exceptions.SequencesNotSupportedException;
import org.hotrod.exceptions.UnresolvableDataTypeException;
import org.hotrod.generator.DAOType;
import org.hotrod.metadata.AutoGeneratedColumnMetadata;
import org.hotrod.metadata.ColumnMetadata;
import org.hotrod.metadata.DataSetMetadata;
import org.hotrod.metadata.EnumDataSetMetadata;
import org.hotrod.metadata.KeyMetadata;
import org.hotrod.metadata.VersionControlMetadata;
import org.hotrod.runtime.util.ListWriter;
import org.hotrod.runtime.util.SUtils;
import org.hotrod.utils.ClassPackage;
import org.hotrod.utils.identifiers.DataSetIdentifier;
import org.hotrod.utils.identifiers.Identifier;
import org.nocrala.tools.database.tartarus.core.JdbcColumn.AutogenerationType;
import org.nocrala.tools.database.tartarus.exception.ReaderException;

public class Mapper {

  private static final Logger log = Logger.getLogger(Mapper.class);

  private DataSetMetadata metadata;
  private DataSetLayout layout;

  private HotRodFragmentConfigTag fragmentConfig;
  private ClassPackage fragmentPackage;

  private AbstractCompositeDAOTag compositeTag;
  @SuppressWarnings("unused")
  private SelectTag selectTag;

  private MyBatisGenerator generator;

  private DAOType type;

  @SuppressWarnings("unused")
  private DatabaseAdapter adapter;

  private String namespace;

  private ObjectVO vo;
  private ObjectDAO dao;

  private Writer w;

  public Mapper(final AbstractCompositeDAOTag compositeTag, final DataSetMetadata metadata, final DataSetLayout layout,
      final MyBatisGenerator generator, final DAOType type, final DatabaseAdapter adapter, final ObjectVO vo) {
    log.debug("init");
    this.compositeTag = compositeTag;
    this.selectTag = null;
    initialize(metadata, layout, generator, type, adapter, vo);
  }

  public Mapper(final SelectTag selectTag, final DataSetMetadata metadata, final DataSetLayout layout,
      final MyBatisGenerator generator, final DAOType type, final DatabaseAdapter adapter, final ObjectVO vo) {
    log.debug("init");
    this.compositeTag = null;
    this.selectTag = selectTag;
    initialize(metadata, layout, generator, type, adapter, vo);
  }

  private void initialize(final DataSetMetadata metadata, final DataSetLayout layout, final MyBatisGenerator generator,
      final DAOType type, final DatabaseAdapter adapter, final ObjectVO vo) {
    this.metadata = metadata;

    this.fragmentConfig = this.metadata.getFragmentConfig();
    this.fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage() : null;

    this.layout = layout;
    this.generator = generator;

    if (type == null) {
      throw new RuntimeException("DAOType cannot be null.");
    }
    this.type = type;
    this.adapter = adapter;
    this.vo = vo;

    this.namespace = this.layout.getDAOPrimitivePackage(this.fragmentPackage).getPackage() + "."
        + this.metadata.getIdentifier().getJavaMemberIdentifier();
  }

  public void setDao(ObjectDAO dao) {
    this.dao = dao;
  }

  private boolean isTable() {
    return this.type == DAOType.TABLE;
  }

  @SuppressWarnings("unused")
  private boolean isView() {
    return this.type == DAOType.VIEW;
  }

  private boolean isSelect() {
    return this.type == DAOType.SELECT;
  }

  public void generate() throws UncontrolledException, ControlledException {
    String sourceFileName = this.getSourceFileName();

    ClassPackage fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage() : null;

    File mapper = new File(this.layout.getMapperPrimitiveDir(fragmentPackage), sourceFileName);
    this.w = null;

    try {
      this.w = new BufferedWriter(new FileWriter(mapper));

      writeHeader();

      writeColumns();

      writeResultMap();

      if (this.isTable()) {
        writeSelectByPK();
        writeSelectByUI();
      }

      if (this.isSelect()) {
        writeSelectParameterized();
      } else {
        writeSelectByExample();
      }

      if (this.isTable()) {
        writeInsert();
        writeUpdateByPK();
        writeDeleteByPK();
      }

      writeInsertByExample();
      writeUpdateByExample();
      writeDeleteByExample();

      if (this.compositeTag != null) {

        for (SequenceTag s : this.compositeTag.getSequences()) {
          try {
            writeSelectSequence(s);
          } catch (SequencesNotSupportedException e) {
            throw new ControlledException(
                "Could not generate mapper for sequence '" + s.getName() + "' onto file: " + e.getMessage());
          }
        }

        for (QueryTag q : this.compositeTag.getQueries()) {
          try {
            writeQuery(q);
          } catch (SequencesNotSupportedException e) {
            throw new ControlledException(
                "Could not generate mapper for query '" + q.getJavaMethodName() + "' onto file: " + e.getMessage());
          }
        }

      }

      writeFooter();

    } catch (IOException e) {
      throw new UncontrolledException(
          "Could not generate mapper file: could not write to file '" + mapper.getName() + "'.", e);
    } catch (UnresolvableDataTypeException e) {
      throw new ControlledException(
          "Could not generate mapper file: " + "could not resolve the database column type: " + e.getMessage());
    } catch (AutogeneratedKeysNotSupportedException e) {
      throw new ControlledException("Could not generate mapper file: " + e.getMessage());
    } finally {
      if (this.w != null) {
        try {
          this.w.close();
        } catch (IOException e) {
          throw new UncontrolledException(
              "Could not generate mapper file: could not close file '" + mapper.getName() + "'.", e);
        }
      }
    }
  }

  /**
   * <pre>
   * <?xml version="1.0" encoding="UTF-8" ?>
   * <!DOCTYPE mapper
   *   PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
   *   "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   * <mapper namespace="simpletests.dao">
   * </pre>
   * 
   * @throws IOException
   */

  private void writeHeader() throws IOException {
    println("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
    println("<!DOCTYPE mapper");
    println("  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"");
    println("  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">");
    println("<mapper namespace=\"" + this.namespace + "\">");
    println();
  }

  /**
   * <pre>
   *   <sql id="columns">
   *     ${prefix}ID as id,
   *     ${prefix}CURRENT_BALANCE as currentBalance,
   *     ${prefix}STARTED_ON as startedOn
   *   </sql>
   * </pre>
   * 
   * @throws IOException
   */
  private void writeColumns() throws IOException {

    // Without prefix

    println("  <!-- columns -->");
    println();
    println("  <sql id=\"columns\">");

    StringBuilder sb = new StringBuilder("    ");
    ListWriter lw = new ListWriter(",\n    ");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      lw.add(SUtils.escapeXmlBody(cm.renderSQLIdentifier()));
    }
    sb.append(lw.toString());
    println(sb.toString());

    println("  </sql>");
    println();

    // With prefix

    println("  <sql id=\"columnsWithAlias\">");

    sb = new StringBuilder("    ");
    lw = new ListWriter(",\n    ");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      lw.add("${alias}." + SUtils.escapeXmlBody(cm.renderSQLIdentifier()));
    }
    sb.append(lw.toString());
    println(sb.toString());

    println("  </sql>");
    println();

  }

  private static final String RESULT_MAP_NAME = "allColumns";

  /**
   * <pre>
   * 
   * <resultMap id="resultMap" type="hotrod.test.generation.QuadrantDAO">
   *   <id property="region" column="region" />
   *   <id property="area" column="area" />
   *   <result property="caption" column="caption" />
   *   <result property="active" column="active" typeHandler=
  "tests.typehandler.BooleanShortTypeHandler" />
   * </resultMap>
   * 
   * </pre>
   * 
   * @throws IOException
   */

  private void writeResultMap() throws IOException {
    println("  <resultMap id=\"" + RESULT_MAP_NAME + "\" type=\"" + this.vo.getFullClassName() + "\">");

    // First, only the ids

    for (ColumnMetadata cm : this.metadata.getColumns()) {
      if (cm.belongsToPK()) {
        renderResultMapColumn(cm, "id");
      }
    }

    // Then, the non-ids

    for (ColumnMetadata cm : this.metadata.getColumns()) {
      if (!cm.belongsToPK()) {
        renderResultMapColumn(cm, "result");
      }
    }

    println("  </resultMap>");
    println();
  }

  private void renderResultMapColumn(final ColumnMetadata cm, final String tagName) throws IOException {

    String typeHandler = "";
    if (cm.getConverter() != null) {
      typeHandler = "typeHandler=\"" + this.dao.getTypeHandlerFullClassName(cm) + "\" ";
    } else {
      EnumDataSetMetadata ds = cm.getEnumMetadata();
      EnumClass ec = this.generator.getEnum(ds);
      if (ec != null) {
        typeHandler = "typeHandler=\"" + this.dao.getTypeHandlerFullClassName(cm) + "\" ";
      }
    }

    println("    <" + tagName + " property=\"" + cm.getIdentifier().getJavaMemberIdentifier() + "\" column='"
        + SUtils.escapeXmlAttribute(cm.getColumnName()) + "' " + typeHandler + "/>");

  }

  private void writeSelectByPK() throws IOException {
    if (this.metadata.getPK() == null) {
      println("  <!-- select by PK: no mapping generated, since the table does not have a PK -->");
      println();
    } else {
      println("  <!-- select by PK -->");
      println();
      println("  <select id=\"" + this.getMapperIdSelectByPK() + "\" resultMap=\"" + RESULT_MAP_NAME + "\">");
      println("    select");
      println("      <include refid=\"columns\" />");
      println("     from " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()));
      println("     where");
      println(getWhereByIndex(this.metadata.getPK()));
      println("  </select>");
      println();
    }
  }

  private void writeSelectByUI() throws IOException {
    if (this.metadata.getUniqueIndexes().isEmpty()) {
      println("  <!-- select by unique indexes: no mappings generated, " + "since the table does not have UIs -->");
      println();
    } else {
      boolean first = true;

      // Remove duplicated unique indexes/constraints that may be registered in
      // the database. This behavior has been observed in PostgreSQL.

      Set<KeyMetadata> distinctConstraints = new LinkedHashSet<KeyMetadata>();
      for (KeyMetadata ui : this.metadata.getUniqueIndexes()) {
        distinctConstraints.add(ui);
      }

      // Generate the primitive method.

      for (KeyMetadata ui : distinctConstraints) {
        if (this.metadata.getPK() == null || !ui.equals(this.metadata.getPK())) {
          if (first) {
            first = false;
            println("  <!-- select by unique indexes -->");
            println();
          }
          println("  <select id=\"" + this.getMapperIdSelectByUI(ui) + "\" resultMap=\"" + RESULT_MAP_NAME + "\">");
          println("    select");
          println("      <include refid=\"columns\" />");
          println("     from " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()));
          println("     where");
          println(getWhereByIndex(ui));
          println("  </select>");
          println();
        }
      }
      if (first) {
        println("  <!-- no select by unique indexes since there are no UI "
            + (this.metadata.getPK() == null ? "" : "(besides the PK) ") + "-->");
        println();
      }
    }
  }

  /**
   * <pre>
   *   <select id="selectAbc" resultType="dao.AbcDAO">
   *     select * from abc 
   *     <where>
   *       <if test="state != null">
   *         and state = #{state}
   *       </if>
   *     </where>
   *     <if test="o != null">
   *       order by ${o}
   *     </if>
   *   </select>
   * </pre>
   * 
   * @throws IOException
   */
  private void writeSelectByExample() throws IOException {
    println("  <!-- select by example -->");
    println();
    println("  <select id=\"" + this.getMapperIdSelectByExample() + "\" resultMap=\"" + RESULT_MAP_NAME + "\">");
    println("    select");
    println("      <include refid=\"columns\" />");
    println("     from " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()));
    print(getWhereByExample("p"));
    println("    <if test=\"o != null\">");
    println("      order by ${o}");
    println("    </if>");
    println("  </select>");
    println();
  }

  /**
   * <pre>
   * 
   *   <!-- select parameterized -->
   * 
   *   <select id="selectParameterized" resultType=
  "com.company.daos.CountryDAO">
   *     select blah, blah, blah
   *       where id = #{id,jdbcType=NUMERIC}
   *        and name = #{name,jdbcType=VARCHAR}
   *       order by name
   *   </select>
   * 
   * </pre>
   */

  private void writeSelectParameterized() throws IOException {
    println("  <!-- select parameterized -->");
    println();
    println("  <select id=\"" + this.getMapperIdSelectParameterized() + "\" resultMap=\"" + RESULT_MAP_NAME + "\">");
    println(this.metadata.renderXML(new MyBatisParameterRenderer()));
    println("  </select>");
    println();
  }

  /**
   * <pre>
   *   <insert id="insertAbc">
   *     <selectKey keyProperty="id" resultType="int" order="BEFORE">
   *       select seq.nextval from dual
   *     </selectKey>
   *     insert into Author (id,username,password,email,bio)
   *     values
   *     (#{id},#{username},#{password},#{email},#{bio})
   *   </insert>
   * </pre>
   * 
   * @throws IOException
   * @throws UnresolvableDataTypeException
   * @throws AutogeneratedKeysNotSupportedException
   */
  private void writeInsert() throws IOException, UnresolvableDataTypeException, AutogeneratedKeysNotSupportedException {
    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();
    if (agcm == null) {
      writeInsertWithoutAutoGeneratedColumn();
    } else {
      if (agcm.isIdentity()) {
        if (agcm.getAutogenerationType() == AutogenerationType.IDENTITY_BY_DEFAULT) {
          writeInsertWithoutAutoGeneratedColumn();
        }
        writeInsertUsingIdentity();
      } else {
        writeInsertUsingSequence();
      }
    }
  }

  private void writeInsertByExample()
      throws IOException, UnresolvableDataTypeException, AutogeneratedKeysNotSupportedException {
    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();
    if (agcm == null) {
      writeInsertByExampleWithoutAutoGeneratedColumn();
    } else {
      if (agcm.isIdentity()) {
        if (agcm.getAutogenerationType() == AutogenerationType.IDENTITY_BY_DEFAULT) {
          writeInsertByExampleWithoutAutoGeneratedColumn();
        }
        writeInsertByExampleUsingIdentity();
      } else {
        writeInsertByExampleUsingSequence();
      }
    }
  }

  private void writeInsertWithoutAutoGeneratedColumn() throws IOException, AutogeneratedKeysNotSupportedException {
    println("  <!-- insert (no auto-generated column) -->");
    println();

    println("  <insert id=\"" + this.getMapperIdInsert() + "\">");
    ListWriter ln = new ListWriter(",\n        ");
    ListWriter lv = new ListWriter(",\n        ");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      ln.add(SUtils.escapeXmlBody(cm.renderSQLIdentifier()));
      lv.add(renderParameterColumn(cm));
    }
    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()) + " (\n        "
        + ln.toString() + "\n      ) values (");
    println("        " + lv.toString() + "\n      )");
    println("  </insert>");
    println();
  }

  private void writeInsertByExampleWithoutAutoGeneratedColumn()
      throws IOException, AutogeneratedKeysNotSupportedException {
    if (this.isTable()) {
      println("  <!-- insert by example (no auto-generated column) -->");
    } else {
      println("  <!-- insert by example (view) -->");
    }
    println();

    println("  <insert id=\"" + this.getMapperIdInsertByExample() + "\">");
    ListWriter ln = new ListWriter("\n");
    ListWriter lv = new ListWriter("\n");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String prop = cm.getIdentifier().getJavaMemberIdentifier();
      ln.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, "
          + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + "</if>");
      lv.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, " + renderParameterColumn(cm) + "</if>");
    }
    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier())
        + " (\n      <trim prefixOverrides=\", \">\n" + ln.toString() + "\n      </trim>\n      ) values (");
    println("      <trim prefixOverrides=\", \">\n" + lv.toString() + "\n      </trim>\n      )");
    println("  </insert>");
    println();
  }

  private void writeInsertUsingIdentity() throws IOException, AutogeneratedKeysNotSupportedException {
    println("  <!-- insert (using identity) -->");
    println();

    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();

    String mapperInsertId = this.getMapperIdInsertWithIdentity();

    if (agcm.supportsJDBCGeneratedKeys()) {
      print("  <insert id=\"" + mapperInsertId + "\"");
      print(" useGeneratedKeys=\"true\" keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\"");
      println(">");
    } else {
      println("  <insert id=\"" + mapperInsertId + "\">");
      println("    <selectKey keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\" resultType=\""
          + agcm.getColumnMetadata().getType().getJavaClassName() + "\" order=\"AFTER\">");
      println("      " + SUtils.escapeXmlBody(this.metadata.getAutoGeneratedKeySentence(agcm)));
      println("    </selectKey>");
    }

    ListWriter ln = new ListWriter(",\n        ");
    ListWriter lv = new ListWriter(",\n        ");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      if (!agcm.getColumnMetadata().equals(cm)) {
        ln.add(SUtils.escapeXmlBody(cm.renderSQLIdentifier()));
        lv.add(renderParameterColumn(cm));
      }
    }
    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()) + " (\n        "
        + ln.toString() + "\n      ) values (");
    println("        " + lv.toString() + "\n      )");
    println("  </insert>");
    println();
  }

  private void writeInsertByExampleUsingIdentity() throws IOException, AutogeneratedKeysNotSupportedException {
    if (this.isTable()) {
      println("  <!-- insert by example (using identity) -->");
    } else {
      println("  <!-- insert by example (view) -->");
    }
    println();

    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();

    String mapperInsertId = this.getMapperIdInsertByExampleWithIdentity();

    if (agcm.supportsJDBCGeneratedKeys()) {
      print("  <insert id=\"" + mapperInsertId + "\"");
      print(" useGeneratedKeys=\"true\" keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\"");
      println(">");
    } else {
      println("  <insert id=\"" + mapperInsertId + "\">");
      println("    <selectKey keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\" resultType=\""
          + agcm.getColumnMetadata().getType().getJavaClassName() + "\" order=\""
          + (agcm.isIdentity() ? "AFTER" : "BEFORE") + "\">");
      println("      " + SUtils.escapeXmlBody(this.metadata.getAutoGeneratedKeySentence(agcm)));
      println("    </selectKey>");
    }

    ListWriter ln = new ListWriter("\n");
    ListWriter lv = new ListWriter("\n");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      if (!agcm.getColumnMetadata().equals(cm)) {
        String prop = cm.getIdentifier().getJavaMemberIdentifier();
        ln.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, "
            + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + "</if>");
        lv.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, " + renderParameterColumn(cm) + "</if>");
      }
    }

    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier())
        + " (\n      <trim prefixOverrides=\", \">\n" + ln.toString() + "\n      </trim>\n      ) values (");
    println("      <trim prefixOverrides=\", \">\n" + lv.toString() + "\n      </trim>\n      )");
    println("  </insert>");
    println();
  }

  private void writeInsertUsingSequence() throws IOException, AutogeneratedKeysNotSupportedException {
    println("  <!-- insert (using sequence) -->");
    println();

    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();
    println("  <insert id=\"" + this.getMapperIdInsert() + "\">");
    println("    <selectKey keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\" resultType=\""
        + agcm.getColumnMetadata().getType().getJavaClassName() + "\" order=\"BEFORE\">");
    println("      " + SUtils.escapeXmlBody(this.metadata.getAutoGeneratedKeySentence(agcm)));
    println("    </selectKey>");

    ListWriter ln = new ListWriter(",\n        ");
    ListWriter lv = new ListWriter(",\n        ");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      ln.add(SUtils.escapeXmlBody(cm.renderSQLIdentifier()));
      lv.add(renderParameterColumn(cm));
    }
    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()) + " (\n        "
        + ln.toString() + "\n      ) values (");
    println("        " + lv.toString() + "\n      )");
    println("  </insert>");
    println();
  }

  private void writeInsertByExampleUsingSequence() throws IOException, AutogeneratedKeysNotSupportedException {
    if (this.isTable()) {
      println("  <!-- insert by example (using sequence) -->");
    } else {
      println("  <!-- insert by example (view) -->");
    }
    println();

    AutoGeneratedColumnMetadata agcm = this.metadata.getAutoGeneratedColumnMetadata();
    println("  <insert id=\"" + this.getMapperIdInsertByExample() + "\">");
    println("    <selectKey keyProperty=\"" + agcm.getIdentifier().getJavaMemberIdentifier() + "\" resultType=\""
        + agcm.getColumnMetadata().getType().getJavaClassName() + "\" order=\""
        + (agcm.isIdentity() ? "AFTER" : "BEFORE") + "\">");
    println("      " + SUtils.escapeXmlBody(this.metadata.getAutoGeneratedKeySentence(agcm)));
    println("    </selectKey>");

    ListWriter ln = new ListWriter("\n");
    ListWriter lv = new ListWriter("\n");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String prop = cm.getIdentifier().getJavaMemberIdentifier();
      ln.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, "
          + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + "</if>");
      lv.add("        <if test=\"propertiesChangeLog." + prop + "WasSet\">, " + renderParameterColumn(cm) + "</if>");
    }
    println("    insert into " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier())
        + " (\n      <trim prefixOverrides=\", \">\n" + ln.toString() + "\n      </trim>\n      ) values (");
    println("      <trim prefixOverrides=\", \">\n" + lv.toString() + "\n      </trim>\n      )");
    println("  </insert>");
    println();
  }

  private String renderParameterColumn(final ColumnMetadata cm) {
    return renderParameterColumn(cm, null);
  }

  private String renderParameterColumn(final ColumnMetadata cm, final String prefix) {
    String name = (prefix != null ? (prefix + ".") : "") + cm.getIdentifier().getJavaMemberIdentifier();
    String jdbcType = "jdbcType=" + cm.getType().getJDBCShortType();
    String typeHandler = null;
    if (cm.getConverter() != null) {
      typeHandler = "typeHandler=" + this.dao.getTypeHandlerFullClassName(cm);
    } else {
      EnumDataSetMetadata ds = cm.getEnumMetadata();
      EnumClass ec = this.generator.getEnum(ds);
      if (ec != null) {
        typeHandler = "typeHandler=" + this.dao.getTypeHandlerFullClassName(cm);
      }
    }

    return "#{" + name + "," + jdbcType + (typeHandler != null ? ("," + typeHandler) : "") + "}";
  }

  /**
   * <pre>
   *   <update id="updateAbc">
   *     update Author set
   *     username = #{username},
   *     password =
   *     #{password},
   *     email =
   *     #{email},
   *     bio = #{bio}
   *     where id = #{id}
   *   </update>
   * </pre>
   * 
   * @throws IOException
   * @throws UnresolvableDataTypeException
   * @throws ReaderException
   */

  private void writeUpdateByPK() throws IOException, UnresolvableDataTypeException {
    if (this.metadata.getPK() == null) {
      println("  <!-- update by PK: no update mapping generated, since the table does not have a PK -->");
      println();
    } else if (this.metadata.getNonPkColumns().isEmpty()) {
      println("  <!-- update by PK: no update mapping generated, since there aren't any columns besides the PK -->");
      println();
    } else {

      VersionControlMetadata vcm = this.metadata.getVersionControlMetadata();
      boolean useVersionControl = vcm != null;

      println("  <!-- update by PK -->");
      println();
      println("  <update id=\"" + this.getMapperIdUpdateByPK() + "\">");
      println("    update " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()) + " set");

      ListWriter lw = new ListWriter(",\n");
      for (ColumnMetadata cm : this.metadata.getNonPkColumns()) {
        String sqlColumn = cm.renderSQLIdentifier();
        if (useVersionControl) {
          if (useVersionControl && vcm.getColumnMetadata().equals(cm)) {
            lw.add("      " + SUtils.escapeXmlBody(sqlColumn) + " = #{nextVersionValue}");
          } else {
            lw.add("      " + SUtils.escapeXmlBody(sqlColumn) + " = " + renderParameterColumn(cm, "p"));
          }
        } else {
          lw.add("      " + SUtils.escapeXmlBody(sqlColumn) + " = " + renderParameterColumn(cm));
        }
      }
      println(lw.toString());

      println("     where");
      if (useVersionControl) {
        println(getWhereByIndex(this.metadata.getPK(), "p"));
      } else {
        println(getWhereByIndex(this.metadata.getPK()));
      }

      if (useVersionControl) {
        ColumnMetadata cm = vcm.getColumnMetadata();
        String sqlColumn = cm.renderSQLIdentifier();

        println("     and");
        println("      " + SUtils.escapeXmlBody(sqlColumn) + " " + "= " + renderParameterColumn(cm));

      }

      println("  </update>");
      println();
    }
  }

  private String getWhereByIndex(final KeyMetadata km) throws IOException {
    return getWhereByIndex(km, null);
  }

  private String getWhereByIndex(final KeyMetadata km, final String prefix) throws IOException {
    ListWriter lw;
    lw = new ListWriter("\n      and ");
    for (ColumnMetadata cm : km.getColumns()) {
      lw.add(SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " = " + renderParameterColumn(cm, prefix));
    }
    return "      " + lw.toString();
  }

  private String getWhereByExample() throws IOException {
    return getWhereByExample(null);
  }

  private String getWhereByExample(final String prefix) throws IOException {
    StringBuilder sb = new StringBuilder();
    sb.append("    <where>\n");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String prompt = prefix != null ? (prefix + ".") : "";
      String prop = prompt + cm.getIdentifier().getJavaMemberIdentifier();
      String propWasSet = prompt + "propertiesChangeLog." + cm.getIdentifier().getJavaMemberIdentifier() + "WasSet";

      sb.append("      <if test=\"" + prop + " != null \">\n");
      sb.append("        and " + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " = "
          + renderParameterColumn(cm, prefix) + "\n");
      sb.append("      </if>\n");

      sb.append("      <if test=\"" + prop + " == null and " + propWasSet + "\">\n");
      sb.append("        and " + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " is null\n");
      sb.append("      </if>\n");

    }
    sb.append("    </where>\n");
    return sb.toString();
  }

  /**
   * <pre>
   *   <update id="updateByExample">
   *     update Author
   *     <set>
   *       <if test="values.username != null">username=#{values.username},</if>
   *       <if test="values.password != null">password=#{values.password},</if>
   *     </set>    
   *     <where>
   *       <if test="filter.state != null">
   *         and state = #{filter.state}
   *       </if>
   *       <if test="filter.title != null">
   *         and title like #{filter.title}
   *       </if>
   *     </where>
   *   </update>
   * </pre>
   * 
   * @throws UnresolvableDataTypeException
   */

  private void writeUpdateByExample() throws IOException, UnresolvableDataTypeException {
    println("  <!-- update by example -->");
    println();
    println("  <update id=\"" + this.getMapperIdUpdateByExample() + "\">");
    println("    update " + this.metadata.renderSQLIdentifier());

    println("    <set>");
    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String propWasSet = "propertiesChangeLog." + cm.getIdentifier().getJavaMemberIdentifier() + "WasSet";
      if (cm.isVersionControlColumn()) {
        println("      " + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " = "
            + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " + 1,");
      } else {
        println("      <if test=\"values." + propWasSet + "\">" + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " = "
            + renderParameterColumn(cm, "values") + ",</if>");
      }
    }
    println("    </set>");

    print(getWhereByExample("filter"));

    println("  </update>");
    println();
  }

  /**
   * <pre>
   *   <delete id="deleteAbc">
   *     delete from Author where id = #{id}
   *   </delete>
   * </pre>
   * 
   * @throws IOException
   * @throws UnresolvableDataTypeException
   */
  private void writeDeleteByPK() throws IOException, UnresolvableDataTypeException {
    if (this.metadata.getPK() == null) {
      println("  <!-- delete by PK: no delete mapping generated, since the table does not have a PK -->");
      println();
    } else {
      println("  <!-- delete by PK -->");
      println();
      println("  <delete id=\"" + this.getMapperIdDeleteByPK() + "\">");
      println("    delete from " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()));
      println("     where");
      println(getWhereByIndex(this.metadata.getPK()));

      VersionControlMetadata vcm = this.metadata.getVersionControlMetadata();
      boolean useVersionControl = vcm != null;

      if (useVersionControl) {
        ColumnMetadata cm = vcm.getColumnMetadata();
        println("     and");
        println("      " + SUtils.escapeXmlBody(cm.renderSQLIdentifier()) + " " + "= " + renderParameterColumn(cm));
      }

      println("  </delete>");
      println();
    }
  }

  private void writeDeleteByExample() throws IOException {
    println("  <!-- delete by example -->");
    println();
    println("  <delete id=\"" + this.getMapperIdDeleteByExample() + "\">");
    println("    delete from " + SUtils.escapeXmlBody(this.metadata.renderSQLIdentifier()));
    print(getWhereByExample());
    println("  </delete>");
    println();
  }

  /**
   * <pre>
   * 
   *   <!-- select sequence <seq-name> -->
   * 
   *   <select id="selectSequence<seq-name>" resultType="java.lang.Long">
   *     ...sql...
   *   </select>
   * 
   * </pre>
   * 
   * @throws SequencesNotSupportedException
   */

  private void writeSelectSequence(final SequenceTag seq) throws IOException, SequencesNotSupportedException {
    println("  <!-- select sequence " + seq.getName() + " -->");
    println();
    println("  <select id=\"" + this.getMapperSelectSequence(seq) + "\" " + "resultType=\"java.lang.Long\">");

    String sentence = this.generator.getAdapter().renderSelectSequence(seq.getIdentifier());
    println("    " + SUtils.escapeXmlBody(sentence));
    println("  </select>");
    println();

  }

  /**
   * <pre>
   * 
   *   <!-- update <update-name> -->
   * 
   *   <update id="<update-name>">
   *     ...sql...
   *   </update>
   * 
   * </pre>
   * 
   */

  private void writeQuery(final QueryTag u) throws IOException, SequencesNotSupportedException {
    println("  <!-- query " + u.getJavaMethodName() + " -->");
    println();

    println("  <update id=\"" + u.getIdentifier().getJavaMemberIdentifier() + "\">");
    String sentence = u.renderXML(new MyBatisParameterRenderer());
    println("    " + sentence);
    println("  </update>");
    println();

  }

  private void writeFooter() throws IOException {
    println("</mapper>");
  }

  // Info

  public String getRuntimeSourceFileName() {
    File dir = this.layout.getMapperRuntimeDir(this.fragmentPackage);
    // log.info("dir=" + dir);
    File source = new File(dir, this.getSourceFileName());
    // log.info("source=" + source.getPath());
    return source.getPath();
  }

  public String getSourceFileName() {
    DataSetIdentifier id = this.metadata.getIdentifier();
    return getSourceFile(id);
  }

  public static String getSourceFile(final Identifier id) {
    return "primitives-" + id.getMapperFileIdentifier() + ".xml";
  }

  public String getMapperIdSelectByPK() {
    return "selectByPK"
    // + this.tid.getMapperIdentifier()
    ;
  }

  public String getFullMapperIdSelectSequence(final SequenceTag s) {
    return this.namespace + "." + getMapperSelectSequence(s);
  }

  public String getMapperSelectSequence(final SequenceTag s) {
    return "selectSequence" + s.getIdentifier().getJavaClassIdentifier();
  }

  public String getFullMapperIdSelectByPK() {
    return this.namespace + "." + getMapperIdSelectByPK();
  }

  public String getMapperIdSelectByUI(final KeyMetadata ui) {
    return "selectByUI" + ui.toCamelCase(this.layout.getColumnSeam());
  }

  public String getFullMapperIdSelectByUI(final KeyMetadata ui) {
    return this.namespace + "." + getMapperIdSelectByUI(ui);
  }

  public String getMapperIdSelectByExample() {
    return "selectByExample";
  }

  public String getFullMapperIdSelectByExample() {
    return this.namespace + "." + getMapperIdSelectByExample();
  }

  public String getMapperIdSelectParameterized() {
    return "selectParameterized";
  }

  public String getFullMapperIdSelectParameterized() {
    return this.namespace + "." + getMapperIdSelectParameterized();
  }

  public String getMapperIdInsert() {
    return "insert";
  }

  public String getFullMapperIdInsert() {
    return this.namespace + "." + getMapperIdInsert();
  }

  public String getMapperIdInsertWithIdentity() {
    return "insertWithIdentity";
  }

  public String getFullMapperIdInsertWithIdentity() {
    return this.namespace + "." + getMapperIdInsertWithIdentity();
  }

  public String getMapperIdInsertByExampleWithIdentity() {
    return "insertByExampleWithIdentity";
  }

  public String getFullMapperIdInsertByExampleWithIdentity() {
    return this.namespace + "." + getMapperIdInsertByExampleWithIdentity();
  }

  public String getMapperIdInsertByExample() {
    return "insertByExample";
  }

  public String getFullMapperIdInsertByExample() {
    return this.namespace + "." + getMapperIdInsertByExample();
  }

  public String getMapperIdUpdateByPK() {
    return "updateByPK";
  }

  public String getFullMapperIdUpdateByPK() {
    return this.namespace + "." + getMapperIdUpdateByPK();
  }

  public String getMapperIdUpdateByExample() {
    return "updateByExample";
  }

  public String getFullMapperIdUpdateByExample() {
    return this.namespace + "." + getMapperIdUpdateByExample();
  }

  public String getMapperIdDeleteByPK() {
    return "deleteByPK";
  }

  public String getFullMapperIdDeleteByPK() {
    return this.namespace + "." + getMapperIdDeleteByPK();
  }

  public String getMapperIdDeleteByExample() {
    return "deleteByExample";
  }

  public String getFullMapperIdDeleteByExample() {
    return this.namespace + "." + getMapperIdDeleteByExample();
  }

  public String getNamespace() {
    return this.namespace;
  }

  public String getFullMapperIdUpdate(final QueryTag u) {
    return this.namespace + "." + getMapperSelectSequence(u);
  }

  public String getMapperSelectSequence(final QueryTag u) {
    return u.getIdentifier().getJavaMemberIdentifier();
  }

  // Helpers

  private void print(final String txt) throws IOException {
    this.w.write(txt);
  }

  private void println(final String txt) throws IOException {
    this.w.write(txt);
    println();
  }

  private void println() throws IOException {
    this.w.write("\n");
  }

}
