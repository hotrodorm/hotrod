package org.hotrod.generator.mybatis;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.hotrod.ant.Constants;
import org.hotrod.ant.ControlledException;
import org.hotrod.ant.UncontrolledException;
import org.hotrod.config.HotRodConfigTag;
import org.hotrod.config.HotRodFragmentConfigTag;
import org.hotrod.config.MyBatisTag;
import org.hotrod.config.ParameterTag;
import org.hotrod.config.QueryMethodTag;
import org.hotrod.config.SQLParameter;
import org.hotrod.config.SequenceMethodTag;
import org.hotrod.exceptions.SequencesNotSupportedException;
import org.hotrod.generator.ParameterRenderer;
import org.hotrod.metadata.ColumnMetadata;
import org.hotrod.metadata.DAOMetadata;
import org.hotrod.metadata.SelectMethodMetadata;
import org.hotrod.metadata.SelectMethodMetadata.SelectMethodReturnType;
import org.hotrod.metadata.SelectParameterMetadata;
import org.hotrod.runtime.tx.TxDemarcator;
import org.hotrod.runtime.tx.TxManager;
import org.hotrod.runtime.util.ListWriter;
import org.hotrod.runtime.util.SUtils;
import org.hotrod.utils.ClassPackage;
import org.hotrod.utils.ImportsRenderer;
import org.hotrod.utils.identifiers.Identifier;

public class CustomDAO {

  private static final Logger log = Logger.getLogger(CustomDAO.class);

  private DataSetLayout layout;
  private DAOMetadata dm;
  private MyBatisGenerator generator;
  private MyBatisTag myBatisTag;

  private ClassPackage fragmentPackage;

  private CustomDAOMapper mapper = null;

  private DAOMetadata metadata;
  private ClassPackage classPackage;

  private Writer w;

  public CustomDAO(final DAOMetadata dm, final DataSetLayout layout, final MyBatisGenerator generator,
      final HotRodConfigTag config, final MyBatisTag myBatisTag) {
    this.dm = dm;
    this.layout = layout;
    this.generator = generator;
    this.myBatisTag = myBatisTag;

    HotRodFragmentConfigTag fragmentConfig = this.dm.getFragmentConfig();

    this.metadata = dm;

    this.fragmentPackage = fragmentConfig != null && fragmentConfig.getFragmentPackage() != null
        ? fragmentConfig.getFragmentPackage() : null;

    this.classPackage = this.layout.getDAOPrimitivePackage(this.fragmentPackage);

  }

  public void setMapper(final CustomDAOMapper mapPrimitives) {
    this.mapper = mapPrimitives;
  }

  public void generate() throws UncontrolledException, ControlledException {

    log.info("generating DAO '" + this.dm.getJavaClassName() + "'.");

    String className = this.getClassName() + ".java";
    File prim = new File(this.layout.getDaoPrimitivePackageDir(this.fragmentPackage), className);
    this.w = null;

    try {
      this.w = new BufferedWriter(new FileWriter(prim));

      writeClassHeader();

      for (SequenceMethodTag s : this.dm.getSequences()) {
        writeSelectSequence(s);
      }

      for (QueryMethodTag q : this.dm.getQueries()) {
        writeQuery(q);
      }

      log.info("this.metadata=" + this.metadata);
      for (SelectMethodMetadata s : this.metadata.getSelectsMetadata()) {
        writeSelect(s);
      }

      // writeConverters();

      writeTxManager();

      writeClassFooter();

    } catch (IOException e) {
      throw new UncontrolledException(
          "Could not generate DAO primitives class: could not write to file '" + prim.getName() + "'.", e);
    } catch (SequencesNotSupportedException e) {
      throw new ControlledException(e.getMessage());
    } finally {
      if (this.w != null) {
        try {
          this.w.close();
        } catch (IOException e) {
          throw new UncontrolledException(
              "Could not generate DAO primitives class: could not close file '" + prim.getName() + "'.", e);
        }
      }
    }

  }

  private void writeClassHeader() throws IOException {

    // Comment

    println("// Autogenerated by " + Constants.TOOL_NAME + " -- Do not edit.");
    println();

    // Package

    println("package " + this.classPackage.getPackage() + ";");
    println();

    // Imports

    ImportsRenderer imports = new ImportsRenderer();

    imports.add(java.sql.SQLException.class);
    imports.newLine();

    imports.add("org.apache.ibatis.session.SqlSession");
    imports.add("org.apache.ibatis.session.SqlSessionFactory");
    imports.add(TxManager.class);
    imports.add(TxDemarcator.class);

    imports.newLine();
    imports.add(java.util.List.class);
    imports.newLine();

    for (SelectMethodMetadata sm : this.metadata.getSelectsMetadata()) {
      SelectMethodReturnType rt = sm.getReturnType(this.classPackage);
      imports.add(rt.getVOFullClassName());
    }
    if (!this.metadata.getSelectsMetadata().isEmpty()) {
      imports.newLine();
    }

    this.w.write(imports.render());

    // Class Signature

    println("public class " + this.getClassName() + " implements TxDemarcator {");
    println();

  }

  private void retrieveSqlSession() throws IOException {
    retrieveSqlSession(0);
  }

  /**
   * <pre>
   *     TxManager txm = null;
   *     try {
   *       txm = getTxManager();
   * </pre>
   */
  private void retrieveSqlSession(final int indent) throws IOException {
    String f = SUtils.getFiller(' ', indent * 2);
    println(f + "    TxManager txm = null;");
    println(f + "    try {");
    println(f + "      txm = getTxManager();");
    println(f + "      SqlSession sqlSession = txm.getSqlSession();");
  }

  private void releaseSqlSession() throws IOException {
    releaseSqlSession(0);
  }

  /**
   * <pre>
   *     } finally {
   *       if (txm != null && !txm.isTransactionOngoing()) {
   *         txm.close();
   *       }
   *     }
   * </pre>
   */

  private void releaseSqlSession(final int indent) throws IOException {
    String f = SUtils.getFiller(' ', indent * 2);
    println(f + "    } finally {");
    println(f + "      if (txm != null && !txm.isTransactionOngoing()) {");
    println(f + "        txm.close();");
    println(f + "      }");
    println(f + "    }");
  }

  /**
   * <pre>
   * public static long selectSequenceSeqCodes() throws SQLException {
   *   TxManager txm = null;
   *   try {
   *     txm = getTxManager();
   *     SqlSession sqlSession = txm.getSqlSession();
   *     return selectSequenceSeqCodes(sqlSession);
   *   } finally {
   *     if (txm != null && !txm.isTransactionOngoing()) {
   *       txm.close();
   *     }
   *   }
   * }
   * 
   * public static long selectSequenceSeqCodes(final SqlSession sqlSession) {
   *   return sqlSession.selectOne("hotrod.test.generation.primitives.account.sequenceSeqCodes");
   * }
   * </pre>
   * 
   * @throws IOException
   * @throws SequencesNotSupportedException
   */

  private void writeSelectSequence(final SequenceMethodTag tag) throws IOException, SequencesNotSupportedException {

    println("  // sequence " + tag.getName());
    println();
    println(ObjectDAO.renderJavaComment(this.generator.getAdapter().renderSelectSequence(tag.getIdentifier())));
    println();

    println("  public static long " + tag.getJavaMethodName() + "()");
    println("      throws SQLException {");
    retrieveSqlSession();
    println("      return " + tag.getJavaMethodName() + "(sqlSession);");
    releaseSqlSession();
    println("  }");
    println();

    println("  public static long " + tag.getJavaMethodName() + "(final SqlSession sqlSession) throws SQLException {");
    println("    return (Long) sqlSession.selectOne(");
    println("      \"" + this.mapper.getFullMapperIdSelectSequence(tag) + "\");");
    println("  }");
    println();

  }

  /**
   * <pre>
   * 
   * public static int update-name() throws SQLException {
   *   TxManager txm = null;
   *   try {
   *     txm = getTxManager();
   *     SqlSession sqlSession = txm.getSqlSession();
   *     return update-name(sqlSession);
   *   } finally {
   *     if (txm != null && !txm.isTransactionOngoing()) {
   *       txm.close();
   *     }
   *   }
   * }
   * 
   * public static int update-name(final SqlSession sqlSession) throws SQLException {
   *   return sqlSession.update("hotrod.test.generation.primitives.account.sequenceSeqCodes");
   * }
   * 
   * </pre>
   * 
   * @throws IOException
   */

  private void writeQuery(final QueryMethodTag tag) throws IOException {

    println("  // query " + tag.getJavaMethodName());
    println();

    // println(ObjectDAO.renderJavaComment(tag.getAugmentedSQL()));
    ParameterRenderer parameterRenderer = new ParameterRenderer() {
      @Override
      public String render(final SQLParameter parameter) {
        return "#{" + parameter.getName() + "}";
      }
    };
    println(ObjectDAO.renderJavaComment(tag.renderSQLSentence(parameterRenderer)));

    println();

    Identifier id = tag.getIdentifier();
    String methodName = id.getJavaMemberIdentifier();

    ListWriter pdef = new ListWriter(", ");
    ListWriter pcall = new ListWriter(", ");
    for (ParameterTag p : tag.getParameterDefinitions()) {
      pdef.add("final " + p.getJavaType() + " " + p.getName());
      pcall.add(p.getName());
    }
    String paramDef = pdef.toString();
    String paramCall = pcall.toString();

    // parameter class

    if (!tag.getParameterDefinitions().isEmpty()) {
      println("  public static class " + this.getParamClassName(tag) + " {");
      for (ParameterTag p : tag.getParameterDefinitions()) {
        println("    " + p.getJavaType() + " " + p.getName() + ";");
      }
      println("  }");
      println();
    }

    // main method

    print("  public static int " + methodName + "(");
    print(paramDef);
    println(") throws SQLException {");
    retrieveSqlSession();
    print("      int rows = " + methodName + "(sqlSession");
    if (!tag.getParameterDefinitions().isEmpty()) {
      print(", " + paramCall);
    }
    println(");");
    println("      if (!txm.isTransactionOngoing()) {");
    println("        txm.commit();");
    println("      }");
    println("      return rows;");
    releaseSqlSession();
    println("  }");
    println();

    // core method

    print("  public static int " + methodName + "(final SqlSession sqlSession");
    if (!tag.getParameterDefinitions().isEmpty()) {
      print(", " + paramDef);
    }
    println(") throws SQLException {");
    String objName = null;
    if (!tag.getParameterDefinitions().isEmpty()) {
      objName = provideObjectName(tag.getParameterDefinitions());
      println("    " + this.getParamClassName(tag) + " " + objName + " = new " + this.getParamClassName(tag) + "();");
      for (ParameterTag p : tag.getParameterDefinitions()) {
        println("    " + objName + "." + p.getName() + " = " + p.getName() + ";");
      }
    }
    println("    return sqlSession.update(");
    print("      \"" + this.mapper.getFullMapperIdQuery(tag) + "\"");
    if (!tag.getParameterDefinitions().isEmpty()) {
      print(", " + objName);
    }
    println(");");
    println("  }");
    println();

  }

  private String provideObjectName(final List<ParameterTag> definitions) {

    Set<String> existing = new HashSet<String>();
    for (ParameterTag p : definitions) {
      existing.add(p.getName().toLowerCase());
    }

    int i = 0;
    while (true) {
      String candidate = "param" + i;
      if (!existing.contains(candidate.toLowerCase())) {
        return candidate;
      }
      i++;
    }

  }

  private void writeSelect(final SelectMethodMetadata sm) throws IOException {

    println("  // select method: " + sm.getMethod());
    println();

    SelectMethodReturnType rt = sm.getReturnType(this.classPackage);

    // render comment

    ParameterRenderer parameterRenderer = new ParameterRenderer() {
      @Override
      public String render(final SQLParameter parameter) {
        return "#{" + parameter.getName() + "}";
      }
    };
    String sentence = sm.renderSQLSentence(parameterRenderer);
    println(ObjectDAO.renderJavaComment(sentence));

    println();

    String methodName = sm.getMethod();

    ListWriter pdef = new ListWriter(", ");
    ListWriter pcall = new ListWriter(", ");
    for (SelectParameterMetadata p : sm.getParameterDefinitions()) {
      String name = p.getParameter().getName();
      pdef.add("final " + p.getParameter().getJavaType() + " " + name);
      pcall.add(name);
    }
    String paramDef = pdef.toString();
    String paramCall = pcall.toString();

    // parameter class

    if (!sm.getParameterDefinitions().isEmpty()) {
      println("  public static class " + this.getParamClassName(sm) + " {");
      for (SelectParameterMetadata p : sm.getParameterDefinitions()) {
        println("    " + p.getParameter().getJavaType() + " " + p.getParameter().getName() + ";");
      }
      println("  }");
      println();
    }

    // main method

    print("  public static " + rt.getReturnType() + " " + methodName + "(");
    print(paramDef);
    print(") ");
    this.throwsCheckedException();
    println("{");
    retrieveSqlSession();
    print("      " + rt.getReturnType() + " result = " + methodName + "(sqlSession");
    if (!sm.getParameterDefinitions().isEmpty()) {
      print(", " + paramCall);
    }
    println(");");
    println("      if (!txm.isTransactionOngoing()) {");
    println("        txm.commit();");
    println("      }");
    println("      return result;");
    releaseSqlSession();
    println("  }");
    println();

    // core method

    print("  public static " + rt.getReturnType() + " " + methodName + "(final SqlSession sqlSession");
    if (!sm.getParameterDefinitions().isEmpty()) {
      print(", " + paramDef);
    }
    print(") ");
    this.throwsCheckedException();
    println("{");
    String objName = null;
    if (!sm.getParameterDefinitions().isEmpty()) {
      objName = provideParamObjectName(sm.getParameterDefinitions());
      println("    " + this.getParamClassName(sm) + " " + objName + " = new " + this.getParamClassName(sm) + "();");
      for (SelectParameterMetadata p : sm.getParameterDefinitions()) {
        println("    " + objName + "." + p.getParameter().getName() + " = " + p.getParameter().getName() + ";");
      }
    }
    preCheckedException();

    String myBatisSelectMethod = sm.isMultipleRows() ? "selectList" : "selectOne";
    print(
        "    return sqlSession." + myBatisSelectMethod + "(\"" + this.mapper.getFullSelectMethodStatementId(sm) + "\"");
    if (!sm.getParameterDefinitions().isEmpty()) {
      print(", " + objName);
    }
    println(");");
    postCheckedException();
    println("  }");
    println();

  }

  private void throwsCheckedException() throws IOException {
    if (isCheckedPersistenceException()) {
      print("throws SQLException ");
    }
  }

  private boolean isCheckedPersistenceException() {
    return this.myBatisTag.getProperties().isCheckedPersistenceException();
  }

  private void addCheckedException() throws IOException {
    if (isCheckedPersistenceException()) {
      print("SQLException");
    }
  }

  private void preCheckedException() throws IOException {
    if (isCheckedPersistenceException()) {
      println("    try {");
    }
  }

  private void postCheckedException() throws IOException {
    if (isCheckedPersistenceException()) {
      println("    } catch (RuntimeException e) {");
      println("      throw new SQLException(e);");
      println("    }");
    }
  }

  public String getParamClassName(final SelectMethodMetadata sm) {
    return "Param" + sm.getIdentifier().getJavaClassIdentifier();
  }

  private String provideParamObjectName(final List<SelectParameterMetadata> definitions) {

    Set<String> existing = new HashSet<String>();
    for (SelectParameterMetadata p : definitions) {
      existing.add(p.getParameter().getName().toLowerCase());
    }

    int i = 0;
    while (true) {
      String candidate = "param" + i;
      if (!existing.contains(candidate.toLowerCase())) {
        return candidate;
      }
      i++;
    }

  }

  private void writeConverters() throws IOException {

    // Select columns converters

    log.debug("DAO=" + this.getClassName() + " select converters=" + this.selectTypeHandlerNames.size());

    for (Map<ColumnMetadata, String> selectTypeHandlers : this.selectTypeHandlers.values()) {
      for (ColumnMetadata cm : selectTypeHandlers.keySet()) {
        String thName = selectTypeHandlers.get(cm);
        log.debug("WRITING TYPEHANDLER '" + thName + "'");
        writeTypeHandler("", cm, thName);
      }
    }

  }

  private void writeTypeHandler(final String property, final ColumnMetadata cm, final String typeHandlerClassName)
      throws IOException {
    String interType = cm.getConverter().getJavaIntermediateType();
    String type = cm.getConverter().getJavaType();
    String setter = cm.getConverter().getJdbcSetterMethod();
    String getter = cm.getConverter().getJdbcGetterMethod();
    String converter = cm.getConverter().getJavaClass();

    println("  // TypeHandler for " + (property != null ? "property " + property : "column " + cm.getColumnName())
        + " using Converter " + converter + ".");
    println();
    println("  public static class " + typeHandlerClassName + " implements TypeHandler<" + type + "> {");
    println();
    println("    private static TypeConverter<" + interType + ", " + type + "> CONVERTER = new " + converter + "();");
    println();
    println("    @Override");
    println("    public " + type + " getResult(final ResultSet rs, final String columnName) throws SQLException {");
    println("      " + interType + " value = rs." + getter + "(columnName);");
    println("      if (rs.wasNull()) {");
    println("        value = null;");
    println("      }");
    println("      return CONVERTER.decode(value);");
    println("    }");
    println();
    println("    @Override");
    println("    public " + type + " getResult(final ResultSet rs, final int columnIndex) throws SQLException {");
    println("      " + interType + " value = rs." + getter + "(columnIndex);");
    println("      if (rs.wasNull()) {");
    println("        value = null;");
    println("      }");
    println("      return CONVERTER.decode(value);");
    println("    }");
    println();
    println("    @Override");
    println(
        "    public " + type + " getResult(final CallableStatement cs, final int columnIndex) throws SQLException {");
    println("      " + interType + " value = cs." + getter + "(columnIndex);");
    println("      if (cs.wasNull()) {");
    println("        value = null;");
    println("      }");
    println("      return CONVERTER.decode(value);");
    println("    }");
    println();
    println("    @Override");
    println("    public void setParameter(final PreparedStatement ps, final int columnIndex, final " + type
        + " v, final JdbcType jdbcType)");
    println("        throws SQLException {");
    println("      " + interType + " value = CONVERTER.encode(v);");
    println("      if (value == null) {");
    println("        ps.setNull(columnIndex, jdbcType.TYPE_CODE);");
    println("      } else {");
    println("        ps." + setter + "(columnIndex, value);");
    println("      }");
    println("    }");
    println();
    println("  }");
    println();
  }

  /**
   * <pre>
   * // Transaction demarcation
   * 
   * private static TxManager txManager = null;
   * 
   * public static TxManager getTxManager() throws SQLException {
   *   if (txManager == null) {
   *     synchronized (AccountPrimitives.class) {
   *       if (txManager == null) {
   *         txManager = new TxManager(getSqlSessionFactory());
   *       }
   *     }
   *   }
   *   return txManager;
   * }
   * 
   * public static SqlSessionFactory getSqlSessionFactory() throws SQLException {
   *   return fulltest.FullTestDatabaseSessionFactory.getInstance().getSqlSessionFactory();
   * }
   * 
   * public static SqlSession getSqlSession() throws SQLException {
   *   return getSqlSessionFactory().openSession();
   * }
   * </pre>
   */
  private void writeTxManager() throws IOException {
    println("  // Transaction demarcation");
    println();
    println("  private static TxManager txManager = null;");
    println();
    println("  public static TxManager getTxManager() throws SQLException {");
    println("    if (txManager == null) {");
    println("      synchronized (" + this.getClassName() + ".class) {");
    println("        if (txManager == null) {");
    println("          txManager = new TxManager(getSqlSessionFactory());");
    println("        }");
    println("      }");
    println("    }");
    println("    return txManager;");
    println("  }");
    println();
    println("  public static SqlSessionFactory getSqlSessionFactory() throws SQLException {");
    println("    return " + this.layout.getSessionFactoryGetter() + ";");
    println("  }");
    println();
  }

  private void writeClassFooter() throws IOException {
    println("}");
  }

  // Identifiers

  public String getFullClassName() {
    return this.layout.getDAOPrimitivePackage(this.fragmentPackage).getFullClassName(getClassName());
  }

  public String getClassName() {
    return this.dm.getJavaClassName();
  }

  public String getFullParamClassName(final QueryMethodTag u) {
    return this.getFullClassName() + "." + this.getParamClassName(u);
  }

  public String getParamClassName(final QueryMethodTag u) {
    return "Param" + u.getIdentifier().getJavaClassIdentifier();
  }

  private Map<SelectMethodMetadata, Map<ColumnMetadata, String>> selectTypeHandlers = new HashMap<SelectMethodMetadata, Map<ColumnMetadata, String>>();
  private Set<String> selectTypeHandlerNames = new HashSet<String>();

  private String getTypeHandlerClassName(final SelectMethodMetadata sm, final ColumnMetadata cm) {
    log.debug("sm=" + sm.getMethod() + " # " + cm.getColumnName());
    String thName = null;
    Map<ColumnMetadata, String> typeHandlers = this.selectTypeHandlers.get(sm);
    if (typeHandlers != null) {
      thName = typeHandlers.get(cm);
    }
    boolean added = false;
    if (thName == null) {
      String base = sm.getMethod() + "_" + cm.getIdentifier().getJavaClassIdentifier() + "TypeHandler";
      thName = findNextAvailableThName(base);
      if (typeHandlers == null) {
        typeHandlers = new HashMap<ColumnMetadata, String>();
        this.selectTypeHandlers.put(sm, typeHandlers);
      }
      typeHandlers.put(cm, thName);
      this.selectTypeHandlerNames.add(thName);
      added = true;
    }
    log.debug(this.getClassName() + " / " + cm.getColumnName() + " - TypeHandler=" + thName + " added=" + added
        + " total=" + this.selectTypeHandlerNames.size());
    return thName;
  }

  private String findNextAvailableThName(final String baseName) {
    if (!this.selectTypeHandlerNames.contains(baseName)) {
      return baseName;
    }
    for (int i = 2; i < Integer.MAX_VALUE; i++) {
      String candidate = baseName + i;
      if (!this.selectTypeHandlerNames.contains(candidate)) {
        return candidate;
      }
    }
    return null;
  }

  public String getTypeHandlerFullClassName(final SelectMethodMetadata sm, final ColumnMetadata cm) {
    return this.getFullClassName() + "$" + getTypeHandlerClassName(sm, cm);
  }

  // Helpers

  private void print(final String txt) throws IOException {
    this.w.write(txt);
  }

  private void println(final String txt) throws IOException {
    this.w.write(txt);
    println();
  }

  private void println() throws IOException {
    this.w.write("\n");
  }

}
