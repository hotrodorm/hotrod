package org.hotrod.database;

import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.hotrod.config.ColumnTag;
import org.hotrod.config.HotRodConfigTag;
import org.hotrod.config.TableTag;
import org.hotrod.database.PropertyType.ValueRange;
import org.hotrod.exceptions.AutogeneratedKeysNotSupportedException;
import org.hotrod.exceptions.SequencesNotSupportedException;
import org.hotrod.exceptions.UnresolvableDataTypeException;
import org.hotrod.metadata.AutoGeneratedColumnMetadata;
import org.hotrod.metadata.ColumnMetadata;
import org.hotrod.utils.JdbcTypes;
import org.hotrod.utils.JdbcTypes.JDBCType;
import org.hotrod.utils.identifiers.Identifier;
import org.nocrala.tools.database.tartarus.core.JdbcColumn;
import org.nocrala.tools.database.tartarus.core.JdbcTable;
import org.nocrala.tools.database.tartarus.utils.JdbcUtil;

public abstract class DatabaseAdapter {

  private static final Logger log = Logger.getLogger(DatabaseAdapter.class);

  protected HotRodConfigTag config;
  protected final DatabaseMetaData databaseMedaData;
  private String identifierQuoteString;

  private Map<String, DataType> dataTypes;

  public DatabaseAdapter(final HotRodConfigTag config, final DatabaseMetaData dm) throws SQLException {
    this.config = config;
    this.databaseMedaData = dm;
    this.identifierQuoteString = dm.getIdentifierQuoteString();
    this.dataTypes = DataType.retrieveDataTypes(this.databaseMedaData);
  }

  /**
   * <pre>
   * 
   *   TableTag  -> JdbcTable
   *     |  ^         |  ^
   *     *  |         *  |
   *   ColumnTag -> JdbcColumn
   * 
   * </pre>
   */

  public PropertyType resolveJavaType(final ColumnMetadata md) throws UnresolvableDataTypeException {
    ColumnTag columnTag = md.getTag();
    log.debug("columnTag=" + columnTag);
    if (columnTag == null || columnTag.getJavaType() == null) {
      log.debug("No user-specified column type. Return adapter type.");
      // No user-specified column type. Return adapter type.
      return getAdapterDefaultType(md);
    } else {
      log.debug("User-specified column type. Use it.");
      // User-specified column type. Use it.
      JDBCType jdbcType;
      if (columnTag.getJdbcType() != null) {
        // User specified the JDBC type. Use the user's.
        jdbcType = JdbcTypes.nameToType(columnTag.getJdbcType());
        if (jdbcType == null) {
          throw new UnresolvableDataTypeException(md);
        }
      } else {
        // User did not specify the JDBC type. Get it from the live database.
        jdbcType = JdbcTypes.codeToType(md.getDataType());
        if (jdbcType == null) {
          throw new UnresolvableDataTypeException(md);
        }
      }
      ValueRange range = columnTag.getValueRange();
      if (range == null) {
        range = PropertyType.getDefaultValueRange(columnTag.getJavaType());
      }
      return new PropertyType(columnTag.getJavaType(), jdbcType, columnTag.isLOB(), range);
    }
  }

  public ColumnTag findTableColumnTag(final ColumnMetadata md) throws UnresolvableDataTypeException {
    ColumnTag ct;
    TableTag t = findTableTag(md);
    if (t == null) {
      throw new UnresolvableDataTypeException(md);
    }
    ct = t.findColumnTag(md.getColumnName(), this);
    return ct;
  }

  public TableTag findTableTag(final ColumnMetadata md) {
    String jdbcTableName = md.getTableName();
    for (TableTag t : this.config.getTables()) {
      if (this.isTableIdentifier(jdbcTableName, t.getName())) {
        return t;
      }
    }
    return null;
  }

  public String quoteSQLName(final String name) {
    return this.identifierQuoteString + name + this.identifierQuoteString;
  }

  public TableTag findTableTag(final JdbcTable table) {
    return this.config.getTableTag(table);
  }

  public abstract boolean supportsCatalog();

  public abstract boolean supportsSchema();

  public abstract String getName();

  public abstract PropertyType getAdapterDefaultType(ColumnMetadata cm) throws UnresolvableDataTypeException;

  public abstract String getAutoGeneratedKeySentence(AutoGeneratedColumnMetadata agcm)
      throws AutogeneratedKeysNotSupportedException;

  public abstract String renderSelectSequence(final Identifier identifier) throws SequencesNotSupportedException;

  public abstract boolean isTableIdentifier(String jdbcName, String name);

  public abstract boolean isColumnIdentifier(String jdbcName, String name);

  public abstract String formatSchemaName(String name);

  public abstract String createOrReplaceView(String viewName, String select);

  public abstract String dropView(String viewName);

  public abstract String formatJdbcTableName(String tableName);

  public abstract boolean isSerial(JdbcColumn c);

  public abstract boolean useIdentityGeneratedKeysOnInsert();

  // Sorting

  /**
   * Default implementation
   */
  public boolean isCaseSensitiveSortableString(final ColumnMetadata cm) {
    DataType dataType = this.dataTypes.get(cm.getTypeName());
    log.debug("dataType=" + dataType);
    return dataType != null && dataType.caseSensitive && dataType.searchable;
  }

  public abstract String renderForCaseInsensitiveOrderBy(final ColumnMetadata cm);

  // Utilities

  protected PropertyType produceType(final Class<?> c, final ColumnMetadata m, final boolean isLOB)
      throws UnresolvableDataTypeException {
    JDBCType jdbcType = JdbcTypes.codeToType(m.getDataType());
    if (jdbcType == null) {
      throw new UnresolvableDataTypeException(m);
    }
    return new PropertyType(c.getName(), jdbcType, isLOB);
  }

  // Classes

  private static class DataType {

    private String typeName;
    private int dataType;
    private boolean caseSensitive;
    private boolean searchable;

    public static Map<String, DataType> retrieveDataTypes(final DatabaseMetaData databaseMedaData) throws SQLException {
      Map<String, DataType> dataTypes = new HashMap<String, DataType>();
      ResultSet rs = null;
      try {
        rs = databaseMedaData.getTypeInfo();
        while (rs.next()) {
          DataType t = new DataType();
          t.typeName = JdbcUtil.getString(rs, 1);
          t.dataType = JdbcUtil.getInt(rs, 2);
          t.caseSensitive = rs.getBoolean(8);
          if (rs.wasNull()) {
            t.caseSensitive = false;
          }
          Integer searchableValue = JdbcUtil.getIntObj(rs, 9);
          t.searchable = searchableValue != null && searchableValue.equals(DatabaseMetaData.typeSearchable);
          log.debug("DB TYPE: " + t);
          dataTypes.put(t.typeName, t);
        }
        return dataTypes;
      } finally {
        JdbcUtil.closeDbResources(rs);
      }
    }

    public String toString() {
      // ReflectionToStringBuilder a;
      return "typeName:" + this.typeName + " dataType=" + this.dataType + " caseSensitive=" + this.caseSensitive
          + " searchable=" + this.searchable;
    }

  }

}
