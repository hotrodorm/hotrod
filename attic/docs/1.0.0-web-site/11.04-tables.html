<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title></title>
<link rel="stylesheet" href="styles/lightweight.css">

<script src="jquery/jquery-3.1.1.min.js"></script>

<link rel="stylesheet" href="highlight/styles/vs.css">
<script src="highlight/highlight.pack.js"></script>
<script>
  $(document).ready(function() {
    $('pre').each(function(i, block) {
      hljs.highlightBlock(block);
    });
  });
</script>

</head>
<body>

  <table>
    <tr>
      <td><img src="images/hotrod-logo-70.png"
        style="display: inline;" /></td>
      <td>
        <p style="font-size: 30px; margin: 0; padding-left: 15px;">Advanced
          Database Persistence for Java</p>
        <p style="font-size: 18px; margin: 0; padding-left: 15px;">Examples
          &amp; Reference Manual</p>
      </td>
    </tr>
  </table>

  <div
    style="width: 100%; border-bottom: 2px solid #c0c0c0; font-size: 6px;">&nbsp;</div>

  <div>

    <ul class="menu">
      <li><a href="01-welcome-to-hotrod.html">Welcome to
          HotRod!</a></li>
      <li><a href="02-apache-2.0-license.html">Apache 2.0
          License</a></li>
      <li><a href="03-downloads.html">Downloads</a></li>
      <li><a href="04-hello-world-mybatis.html">Hello World MyBatis!</a></li>
      <li><a href="05-source-code.html">Source Code</a></li>
      <li><a href="06.1-ant-task.html">Ant Task</a></li>
      <li><a href="06.2-development-acceleration.html">Development Acceleration Using Hotrod</a></li>
      <li><a href="07.01-mybatis-generator.html">MyBatis Generator</a></li>
      <li class="menu2"><a href="07.02-mybatis-cheat-sheet.html">MyBatis Cheat Sheet</a></li>
      <li class="menu2"><a href="07.03-how-to-run-the-examples.html">How to Run the Examples</a></li>
      <li class="menu2"><a href="07.04-example01.html">Example 1 - Basic CRUD
          Operations on Tables</a></li>
      <li class="menu2"><a href="07.04-example02.html">Example 2 - Using
          Sequences &amp; Identity PKs</a></li>
      <li class="menu2"><a href="07.04-example03.html">Example 3 - Select by
          Example</a></li>
      <li class="menu2"><a href="07.04-example04.html">Example 4 - Update by
          Example</a></li>
      <li class="menu2"><a href="07.04-example05.html">Example 5 - Delete by
          Example</a></li>
      <li class="menu2"><a href="07.04-example06.html">Example 6 - Navigating
          Foreign Keys</a></li>
      <li class="menu2"><a href="07.04-example07.html">Example 7 - Select by
          Unique Indexes</a></li>
      <li class="menu2"><a href="07.04-example08.html">Example 8 - Selecting
          on Views</a></li>
      <li class="menu2"><a href="07.04-example09.html">Example 9 - Retrieving
          Sequence Values</a></li>
      <li class="menu2"><a href="07.04-example10.html">Example 10 - Regular
          SQL Queries</a></li>
      <li class="menu2"><a href="07.04-example11.html">Example 11 - Custom
          DAOs</a></li>
      <li class="menu2"><a href="07.04-example12.html">Example 12 - Regular
          SQL Selects</a></li>
      <li class="menu2"><a href="07.04-example13.html">Example 13 - Native SQL</a></li>
      <li class="menu2"><a href="07.04-example14.html">Example 14 - Dynamic
          SQL</a></li>
      <li class="menu2"><a href="07.04-example15.html">Example 15 -
          Transactions &amp; Isolation Levels</a></li>
      <li class="menu2"><a href="07.04-example16.html">Example 16 - Optimistic
          Locking (Row Version Control)</a></li>
      <li class="menu2"><a href="07.04-example17.html">Example 17 - Custom DAO
          Class Names</a></li>
      <li class="menu2"><a href="07.04-example18.html">Example 18 - Custom DAO
          Property Names</a></li>
      <li class="menu2"><a href="07.04-example19.html">Example 19 - Custom DAO
          Property Java Types</a></li>
      <li class="menu2"><a href="07.04-example20.html">Example 20 - Fragments</a></li>
      <li class="menu2"><a href="07.04-example21.html">Example 21 - Facets</a></li>
      <li class="menu2"><a href="07.04-example22.html">Example 22 - Including
          Existing MyBatis Mappers</a></li>
      <li><a href="09-project-setup.html">Project Setup</a></li>
      <li><a href="10-database-support.html">Supported Databases &amp; Column Types</a></li>
      <li class="menu2"><a href="10.01-oracle.html">Oracle Database</a></li>
      <li class="menu2"><a href="10.02-db2.html">IBM DB2</a></li>
      <li class="menu2"><a href="10.03-sapase.html">SAP ASE / Sybase</a></li>
      <li class="menu2"><a href="10.04-sqlserver.html">Microsoft SQL Server</a></li>
      <li class="menu2"><a href="10.05-postgresql.html">PostgreSQL</a></li>
      <li class="menu2"><a href="10.06-mysql.html">MySQL</a></li>
      <li class="menu2"><a href="10.07-mariadb.html">MariaDB</a></li>
      <li class="menu2"><a href="10.08-hypersql.html">HyperSQL (HSQLDB)</a></li>
      <li class="menu2"><a href="10.09-h2.html">H2</a></li>
      <li><a href="11.01-configuration-reference.html">Configuration Reference</a></li>
      <li class="menu2"><a href="11.02-mybatis-generator.html">MyBatis Generator</a></li>
      <li class="menu2"><a class="active" href="11.04-tables.html">Tables</a></li>
      <li class="menu2"><a href="11.05-columns.html">Columns</a></li>
      <li class="menu2"><a href="11.06-sequences.html">Sequences</a></li>
      <li class="menu2"><a href="11.07-sql-queries.html">SQL Queries</a></li>
      <li class="menu2"><a href="11.08-views.html">Views</a></li>
      <li class="menu2"><a href="11.09-sql-selects.html">SQL Selects</a></li>
      <li class="menu2"><a href="11.10-dynamic-sql.html">Dynamic SQL</a></li>
      <li class="menu2"><a href="11.11-custom-daos.html">Custom DAOs </a></li>
      <li class="menu2"><a href="11.12-fragments.html">Fragments</a></li>
      <li class="menu2"><a href="11.13-facets.html">Facets</a></li>
      <li class="menu2"><a href="11.14-existing-mybatis-mappers.html">Existing MyBatis
          Mappers</a></li>
      <li><a href="12-faq.html">FAQ</a></li>
    </ul>

    <div class="article">

      <!-- ============= -->
      <!-- Article Begin -->
      <!-- ============= -->

<h1>Tables Configuration Reference</h1>

<p>The tables configuration is probably the most important section in the configuration file. Tables usually make up the core of the database objects any application wants to work with and this section is by far the more configurable one, by providing multiple options and tweaks to the developer.</p>

<h2>The &lt;table&gt; Tag</h2>

<p>The <code>&lt;table&gt;</code> tag tells HotRod which tables you want to use. Each <code>&lt;table&gt;</code> tag adds one table to the code generation and produces a DAO. If the database schema has more tables in it they will be ignored if not listed using a <code>&lt;table&gt;</code> tag. Essentially HotRod uses a white list approach when configuring tables.</p>

<p>The <code>&lt;table&gt;</code> tag attributes are:</p>

<table class="data-table">
  <tbody>
    <tr>
      <th><strong>Attribute</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Required</strong></th>
    </tr>
    <tr>
      <td>name</td>
      <td>The name of the database table.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>java-name</td>
      <td>The name of the DAO Java class, if different from the default name produced by HotRod.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>column-seam</td>
      <td>A character String that glues columns together when naming methods that use composite columns in their names. Used when navigating composite FKs and composite unique indexes.</td>
      <td>No</td>
    </tr>
  </tbody>
</table>

<p>A single table definition can be very simple&mdash;it can only declare the name of a table&mdash;or can very quite long&mdash;by including numerous extra attributes and sub-tags to add extra functionality or tweaks. In its simplest form the <code>&lt;table&gt;</code> tag looks like:</p>

<pre class="xml">  &lt;table name="application_log" /></pre>

<p>This informs HotRod there&#39;s an <code>APPLICATION_LOG</code> table that is to included in the code generation. The DAO Java name&mdash;and the properties names for its columns&mdash;will be generated by default from the database table structure, and the Java types will also be produced using the default rules HotRod has for this specific database. Basically, there is no custom configuration on it.</p>

<p>The name of the DAO Java class is taken from the table name, and prepended and appended with the prefix and suffix as specified in the header configuration section of the configuration file. By default there&#39;s no prefix, and by default the suffix is <code>DAO</code>. Therefore, in the example above the <code>APPLICATION_LOG</code> table will produce a DAO Java class&nbsp; <code>ApplicationLogDAO.java</code>.</p>

<p>Now, if you want to use a different name for the DAO Java class, you can specify it in the <code>&lt;table&gt;</code> tag using the <code>java-name</code> attribute. Mind this name must be a valid Java class name, starting with an upper case letter. If, for example, we wanted to use a custom name for the DAO the configuration could look like:</p>

<pre class="xml">  &lt;table name="application_log" java-name="AppLog" /></pre>

<p>This configuration will produce the DAO Java class <code>AppLog.java</code>. Notice that when you openly specify the DAO Java name, HotRod does not prepend or append the prefix and suffix, but it takes it exactly as you declared it.</p>

<h2>The &lt;auto-generated-column&gt; tag</h2>

<p>Most tables with a primary key produce their values either as an auto-generated column with values provided by the database itself, or using a sequence whose values are also generated by the database. Some databases offer the first solution, other ones offer the second, and some databases offer both options.</p>

<p>The <code>&lt;auto-generated-column&gt;</code> tag tells the code generator the database will provide values for the each row when it&#39;s inserted into the table. Because of the different PK generation strategies mentioned before the <code>&lt;auto-generated-column&gt;</code> tag can take different forms.</p>

<p>The <code>&lt;auto-generated-column&gt;</code> tag attributes are:</p>

<table class="data-table">
  <tbody>
    <tr>
      <th><strong>Attribute</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Required</strong></th>
    </tr>
    <tr>
      <td>name</td>
      <td>The name of the primary key column.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>sequence</td>
      <td>The name of the database sequence to use when generating values for the PK while inserting new rows. If not specified, the PK is considered to be an identity PK.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>allows-specified-value</td>
      <td>Tells the code generator that if the DAO property for the PK has a non-null value, this value should be used while inserting the row, ignoring the auto-generation mechanism. Valid values are <code>true</code> or <code>false</code>. Defaults to <code>false</code>.</td>
      <td>No</td>
    </tr>
  </tbody>
</table>

<h3>Identity Primary Key</h3>

<p>If the PK value is generated as an identity PK the table could be configured as:</p>

<pre class="xml">  &lt;table name="client">
    &lt;auto-generated-column name="client_id" />
  &lt;/table></pre>

<p>This configuration setting tell the code generator the table <code>CLIENT</code> has primary key column <code>CLIENT_ID</code> whose value is generated by the database on every inserted row. Any value on the <code>clientId</code> DAO property the developer may have set before inserting the row will be ignored, in favor of the value produced by the database. Additionally, the newly inserted PK value will be loaded back into the DAO right after the insertion, so the application can start using it right away.</p>

<p><strong>Note for identity columns on Oracle 12c</strong>: even though Oracle 12c supports <code>IDENTITY</code> columns, there seem to be lacking JDBC driver support to retrieve the newly generated value during an insert. Therefore, HotRod allows the use of <code>IDENTITY</code> columns, but is not able to retrieve their value during insert. After an <code>insert()</code> operation is executed, the newly inserted table row will have a value in the column, but the DAO property won&#39;t be populated back and will have null value. This only affects Oracle 12c, and not other databases or other version of Oracle.</p>

<h3>Sequence Generated Primary Key</h3>

<p>If the PK value is generated using a database sequence the table could be configured as:</p>

<pre class="xml">  &lt;table name="branch">
    &lt;auto-generated-column name="branch_id" sequence="branch_seq" />
  &lt;/table></pre>

<p>These configuration settings tell the code generator the table <code>BRANCH</code> has a primary key column <code>BRANCH_ID</code> whose value is generated by the database on every inserted row using the sequence <code>BRANCH_SEQ</code>. Any value on the <code>branchId</code> DAO property the developer may have set before inserting the row will be ignored, in favor of the value produced by the database sequence. Additionally, the newly inserted PK value will be loaded back into the DAO right after the insertion, so the application can start using it right away.</p>

<h3>Optionally Generated Identity Primary Key</h3>

<p>Some databases can allow database tables to honor the PK value set by the application while inserting the row on tables with auto-generated PK values. If you happen to have a database or a table configured to support this feature, it can be configured in HotRod as:</p>

<pre class="xml">  &lt;table name="purchase">
    &lt;auto-generated-column name="purchase_id"
      allows-specified-value="true" />
  &lt;/table></pre>

<p>These configuration settings tell the code generator the table <code>PURCHASE</code> has a primary key column <code>PURCHASE_ID</code> whose value is generated by the database on every inserted row. If no value is set (or a null value is set) on the <code>purchaseId</code> property of the DAO the database will generate the PK value, and this newly generated value will be loaded back into the DAO right after the insertion. However, if a non-null value is set on the <code>purchaseId</code> property of the DAO this value will be honored while inserting the row so no auto-generated value will be produced by the database.</p>

<p><strong>Note for identity columns on Oracle 12c</strong>: When the <code>IDENTITY</code> column value is set to null HotRod cannot retrieve its value during an <code>insert()</code> operation. In the database table the new row will have a new valid value, but the HotRod DAO will still have a null value. This only affects Oracle 12c. See note above.</p>

<p>The example below for H2 database depicts the usage of this feature using plain SQL:</p>

<pre class="sql">  create table test(id bigint auto_increment, name varchar(255));

  insert into test(name) values('hello');
  insert into test(id, name) values(123, 'world'); -- Overrides PK!

  select * from test;</pre>

<p>The last SQL <code>select</code> shows both rows inserted with the PK values <code>1</code> and <code>123</code>. If the <code>ID</code> column hadn&#39;t been specified on the second <code>insert</code> its PK value would have been <code>2</code> instead of <code>123</code>.</p>

<p>The following table shows which databases support the optional identity PK value:</p>

<table class="data-table">
  <tbody>
    <tr>
      <th><strong>Database</strong></th>
      <th><strong>Support Details</strong></th>
    </tr>
    <tr>
      <td>Oracle Database</td>
      <td>Not supported on Oracle 11g or older. Starting on Oracle 12c there is support for <code>identity</code> PKs. If using Oracle 12c, then:<br />
      Allowed on <code>generated by default</code> PKs. New column value is not retrieved and remains null.<br />
      Not allowed on <code>generated always</code> PKs.</td>
    </tr>
    <tr>
      <td>IBM DB2</td>
      <td>Allowed on <code>generated by default</code> PKs.<br />
      Not allowed on <code>generated always</code> PKs.</td>
    </tr>
    <tr>
      <td>SAP ASE (ex-Sybase)</td>
      <td>Not supported by HotRod.<br />
      SAP ASE provides this functionality (turned off by default) by turning it on temporarily in the session for a single table at a time using:<br />
      <code>set identity_insert &lt;TABLE&gt; on</code><br />
      Since this strategy is cumbersome and error prone HotRod does not support explicit PK values in SAP ASE.</td>
    </tr>
    <tr>
      <td>Microsoft SQL Server</td>
      <td>Not supported by HotRod.<br />
      SQL Server provides this functionality (turned off by default) by turning it on temporarily in the session for a single table at a time using:<br />
      <code>set identity_insert &lt;TABLE&gt; on</code><br />
      Since this strategy is cumbersome and error prone HotRod does not support explicit PK values in Microsoft SQL Server.</td>
    </tr>
    <tr>
      <td>PostgreSQL</td>
      <td>Allowed on all <code>smallserial</code>, <code>serial</code>, and <code>bigserial</code> columns.</td>
    </tr>
    <tr>
      <td>MySQL</td>
      <td>Allowed on all <code>auto_increment</code> columns.</td>
    </tr>
    <tr>
      <td>MariaDB</td>
      <td>Same as in MySQL: allowed on all <code>auto_increment</code> columns.</td>
    </tr>
    <tr>
      <td>HyperSQL (HSQLDB)</td>
      <td>Allowed on all <code>identity</code> PKs.</td>
    </tr>
    <tr>
      <td>H2</td>
      <td>Allowed on all <code>identity</code> PKs.</td>
    </tr>
  </tbody>
</table>

<h2>The &lt;version-control-column&gt; tag</h2>

<p>Some applications opt to implement the Optimistic Locking strategy to deal with data concurrency issues while updating and/or deleting database rows.</p>

<p>Optimistic Locking is a persistence strategy that considers the probability of a row being updated or deleted by another process while the current thread is working with it is fairly low. This strategy requires the table to have a PK, and works by designating another numeric column of the table as the &quot;version control value&quot; of each row. This way it can find out when a row had been updated by another process or thread.</p>

<p>The <code>&lt;version-control-column&gt;</code> tag attributes are:</p>

<table class="data-table">
  <tbody>
    <tr>
      <th><strong>Attribute</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Required</strong></th>
    </tr>
    <tr>
      <td>name</td>
      <td>The name of the table column to be used for row version number purposes. Must be a column of a numeric type, specifically of an integer-like type.</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<p>HotRod implements this strategy automatically behind the scenes if configured to do so. To implement optimistic locking on a table its configuration should look like:</p>

<pre class="xml">  &lt;table name="agent">
    &lt;auto-generated-column name="agent_id" />
    &lt;version-control-column name="row_version" />
  &lt;/table></pre>

<p>The configuration above tells the code generator the table <code>AGENT</code> will use optimistic locking while updating and deleting by primary key, by using the column <code>ROW_VERSION</code> column for version control purposes.</p>

<p>In the example above, if the application reads a row and later tries to update it, the value of the <code>rowVersion</code> DAO property will be checked against the value of the <code>ROW_VERSION</code> column of the table row. If they match the update operation will actually take place. Otherwise&mdash;when the row had been updated or deleted by another process or thread&mdash;, the update operation will fail and will throw a <code>StaleDataException</code>.</p>

<p>Also, in the example above, if the application reads a row and later tries to delete it, the value of the <code>rowVersion</code> DAO property will be checked against the value of the <code>ROW_VERSION</code> column of the table row. If they match the delete operation will actually take place. Otherwise&mdash;when the row had been updated or deleted by another process or thread&mdash;, the delete operation will fail and will throw a <code>StaleDataException</code>.</p>

<h3>Version control column values</h3>

<p>The values of the version control columns are set according to the following rules. When inserting new rows, any value the application may have set on DAO property of the version control column is ignored, and the initial value is inserted on table column of the new row.</p>

<p>On every row update the value incremented, and may eventually cycle back to the initial values after reaching its maximum value.</p>

<p>The initial, maximum, and minimum values depend on the column data type. The initial value is by default zero. The maximum and minimum values depend on the specifics of the column data type. For example, if the column is of type <code>NUMERIC(5)</code>, then the maximum value will be <code>99999</code> and the minimum value will be <code>-99999</code> or zero, depending on if the database accepts negatives number or not for this specific column type.</p>

<p>However, the default initial, maximum, and minimum values can be overridden by the developer by specifying a <code>&lt;column&gt;</code> tag that defines the attributes <code>initial-value</code>, <code>max-value</code>, and <code>min-value</code> respectively. See the <code>&lt;column&gt;</code> tag definition for details.</p>

<p>Not all columns are suitable to be used as version control columns. First, they must be numeric types. Second, they must accept integer numbers only. Therefore, a <code>VARCHAR</code> does not qualify, and neither a <code>DOUBLE</code>, a <code>DATE</code>, or a <code>DECIMAL(10, 2)</code> do. Types such as <code>INTEGER</code>, <code>NUMERIC(10)</code> or <code>BIGINT</code> usually qualify, but this in the end depends on the specifics of each database.</p>

<h2>The &lt;column&gt; Tag</h2>

<p>Each <code>&lt;table&gt;</code> tag can include one or more <code>&lt;column&gt;</code> tags to stipulate specific properties for some or all the columns of a table. The table columns with no <code>&lt;column&gt;</code> definition use the default properties provided by the code generator.</p>

<p>For details on the settings of a <code>&lt;column&gt;</code> tag see the Configuration Reference section for Columns.</p>

<h2>The &lt;sequence&gt; Tag</h2>

<p>Each <code>&lt;table&gt;</code> tag can include one or more <code>&lt;sequence&gt;</code> tags. These definitions generate a Java method to directly retrieve a value from the specified sequence. There&#39;s no relationship between the named sequence and the table tag; the table DAO only serves as a Java class where to place the corresponding Java method to retrieve the value.</p>

<p>For details on the settings of a <code>&lt;sequence&gt;</code> tag see the Configuration Reference section for Sequences.</p>

<h2>The &lt;query&gt; Tag</h2>

<p>Each <code>&lt;table&gt;</code> tag can include one or more <code>&lt;query&gt;</code> tags. Each <code>&lt;query&gt;</code> tag contains a SQL statement the developer wants to attach as a method to the DAO. There&#39;s no relationship between the SQL statement and the table; the table DAO only serves as a Java class where to place the corresponding Java method that executes the SQL statement. The SQL statement must not necessarily be an SQL update, but can also be an SQL insert, or SQL delete.</p>

<p>For details on how to define an <code>&lt;query&gt;</code> tag see the Configuration Reference section for Updates.</p>

<p>&nbsp;</p>


      <!-- =========== -->
      <!-- Article End -->
      <!-- =========== -->

    </div>

  </div>

</body>
</html>