<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title></title>
<link rel="stylesheet" href="styles/lightweight.css">

<script src="jquery/jquery-3.1.1.min.js"></script>

<link rel="stylesheet" href="highlight/styles/vs.css">
<script src="highlight/highlight.pack.js"></script>
<script>
  $(document).ready(function() {
    $('pre').each(function(i, block) {
      hljs.highlightBlock(block);
    });
  });
</script>

</head>
<body>

  <table>
    <tr>
      <td><img src="images/hotrod-logo-70.png"
        style="display: inline;" /></td>
      <td>
        <p style="font-size: 30px; margin: 0; padding-left: 15px;">Advanced
          Database Persistence for Java</p>
        <p style="font-size: 18px; margin: 0; padding-left: 15px;">Examples
          &amp; Reference Manual</p>
      </td>
    </tr>
  </table>

  <div
    style="width: 100%; border-bottom: 2px solid #c0c0c0; font-size: 6px;">&nbsp;</div>

  <div>

    <ul class="menu">
      <li><a href="01-welcome-to-hotrod.html">Welcome to
          HotRod!</a></li>
      <li><a href="02-apache-2.0-license.html">Apache 2.0
          License</a></li>
      <li><a href="03-downloads.html">Downloads</a></li>
      <li><a href="04-hello-world-mybatis.html">Hello World
          MyBatis!</a></li>
      <li><a href="05-source-code.html">Source Code</a></li>
      <li><a href="06.1-ant-task.html">Ant Task</a></li>
      <li><a class="active"
        href="06.2-development-acceleration.html">Development
          Acceleration Using Hotrod</a></li>
      <li><a href="07.01-mybatis-generator.html">MyBatis
          Generator</a></li>
      <li class="menu2"><a href="07.02-mybatis-cheat-sheet.html">MyBatis
          Cheat Sheet</a></li>
      <li class="menu2"><a
        href="07.03-how-to-run-the-examples.html">How to Run the
          Examples</a></li>
      <li class="menu2"><a href="07.04-example01.html">Example
          1 - Basic CRUD Operations on Tables</a></li>
      <li class="menu2"><a href="07.04-example02.html">Example
          2 - Using Sequences &amp; Identity PKs</a></li>
      <li class="menu2"><a href="07.04-example03.html">Example
          3 - Select by Example</a></li>
      <li class="menu2"><a href="07.04-example04.html">Example
          4 - Update by Example</a></li>
      <li class="menu2"><a href="07.04-example05.html">Example
          5 - Delete by Example</a></li>
      <li class="menu2"><a href="07.04-example06.html">Example
          6 - Navigating Foreign Keys</a></li>
      <li class="menu2"><a href="07.04-example07.html">Example
          7 - Select by Unique Indexes</a></li>
      <li class="menu2"><a href="07.04-example08.html">Example
          8 - Selecting on Views</a></li>
      <li class="menu2"><a href="07.04-example09.html">Example
          9 - Retrieving Sequence Values</a></li>
      <li class="menu2"><a href="07.04-example10.html">Example
          10 - Regular SQL Queries</a></li>
      <li class="menu2"><a href="07.04-example11.html">Example
          11 - Custom DAOs</a></li>
      <li class="menu2"><a href="07.04-example12.html">Example
          12 - Regular SQL Selects</a></li>
      <li class="menu2"><a href="07.04-example13.html">Example
          13 - Native SQL</a></li>
      <li class="menu2"><a href="07.04-example14.html">Example
          14 - Dynamic SQL</a></li>
      <li class="menu2"><a href="07.04-example15.html">Example
          15 - Transactions &amp; Isolation Levels</a></li>
      <li class="menu2"><a href="07.04-example16.html">Example
          16 - Optimistic Locking (Row Version Control)</a></li>
      <li class="menu2"><a href="07.04-example17.html">Example
          17 - Custom DAO Class Names</a></li>
      <li class="menu2"><a href="07.04-example18.html">Example
          18 - Custom DAO Property Names</a></li>
      <li class="menu2"><a href="07.04-example19.html">Example
          19 - Custom DAO Property Java Types</a></li>
      <li class="menu2"><a href="07.04-example20.html">Example
          20 - Fragments</a></li>
      <li class="menu2"><a href="07.04-example21.html">Example
          21 - Facets</a></li>
      <li class="menu2"><a href="07.04-example22.html">Example
          22 - Including Existing MyBatis Mappers</a></li>
      <li><a href="09-project-setup.html">Project Setup</a></li>
      <li><a href="10-database-support.html">Supported
          Databases &amp; Column Types</a></li>
      <li class="menu2"><a href="10.01-oracle.html">Oracle
          Database</a></li>
      <li class="menu2"><a href="10.02-db2.html">IBM DB2</a></li>
      <li class="menu2"><a href="10.03-sapase.html">SAP ASE /
          Sybase</a></li>
      <li class="menu2"><a href="10.04-sqlserver.html">Microsoft
          SQL Server</a></li>
      <li class="menu2"><a href="10.05-postgresql.html">PostgreSQL</a></li>
      <li class="menu2"><a href="10.06-mysql.html">MySQL</a></li>
      <li class="menu2"><a href="10.07-mariadb.html">MariaDB</a></li>
      <li class="menu2"><a href="10.08-hypersql.html">HyperSQL
          (HSQLDB)</a></li>
      <li class="menu2"><a href="10.09-h2.html">H2</a></li>
      <li><a href="11.01-configuration-reference.html">Configuration
          Reference</a></li>
      <li class="menu2"><a href="11.02-mybatis-generator.html">MyBatis
          Generator</a></li>
      <li class="menu2"><a href="11.04-tables.html">Tables</a></li>
      <li class="menu2"><a href="11.05-columns.html">Columns</a></li>
      <li class="menu2"><a href="11.06-sequences.html">Sequences</a></li>
      <li class="menu2"><a href="11.07-sql-queries.html">SQL
          Queries</a></li>
      <li class="menu2"><a href="11.08-views.html">Views</a></li>
      <li class="menu2"><a href="11.09-sql-selects.html">SQL
          Selects</a></li>
      <li class="menu2"><a href="11.10-dynamic-sql.html">Dynamic
          SQL</a></li>
      <li class="menu2"><a href="11.11-custom-daos.html">Custom
          DAOs </a></li>
      <li class="menu2"><a href="11.12-fragments.html">Fragments</a></li>
      <li class="menu2"><a href="11.13-facets.html">Facets</a></li>
      <li class="menu2"><a href="11.14-existing-mybatis-mappers.html">Existing
          MyBatis Mappers</a></li>
      <li><a href="12-faq.html">FAQ</a></li>
    </ul>

    <div class="article">

      <!-- ============= -->
      <!-- Article Begin -->
      <!-- ============= -->

      <h1>Development Acceleration Using HotRod</h1>

      <p>Since its inception the vision of HotRod has been to
        automate all SQL and JDBC code that can be automated, to save
        your wits for the complexity of the application, not the trifles
        of SQL and JDBC.</p>

      <p>HotRod&#39;s goal is to dramatically reduce the effort to
        produce a simple yet efficient persistence layer for your Java
        application. Producing the whole persistence layer with HotRod
        becomes very cheap all the while being very powerful and easy to
        use.</p>

      <h2>The Persistence Layer</h2>

      <p>HotRod defines the persistence layer of a Java application
        as all the Java classes and their operations that allow the
        application to interact with the database in order to retrieve
        data or to produce data changes in the database: in sum all the
        DAO classes and their corresponding SQL select, insert, update,
        and delete statements&mdash;simple or complex&mdash;the
        application needs to fully communicate with the database.</p>

      <p>HotRod initially produces all these DAO Java classes with
        their operations using the existing database structure; later
        on, it refreshes them over time according to the changes this
        structure will necessarily suffer time and time again.</p>

      <h2>The DAOs - HotRod vs the competitors</h2>

      <p>To put it simply, the bulk of the effort of the persistence
        layer is to produce fully functional DAOs and VOs. In HotRod a
        DAO presents the persistence operations as methods and doubles
        itself as a VO with properties for each column. This way, HotRod
        produces one DAO for each table, view, and SQL select the
        developer needs to use.</p>

      <p>Even though HotRod automates all the DAO generation
        it&#39;s worth to stopping here for a moment to understand the
        different steps required to do this and how different tools and
        technologies tackle (or not) each one of them. These details
        will serve you to notice how well HotRod measures against
        standard JEE persistence technologies, and well known Java
        libraries, and tools.</p>

      <p>If a developer were writing each DAO manually the effort
        could be divided into the following coding steps:</p>

      <ol>
        <li>Map the related database column types to suitable Java
          types.</li>
        <li>Write the DAO Java class with its properties, setters,
          and getters.</li>
        <li>Write the DAO methods to implement all the JDBC code
          that sends and retrieves data to and from the database. This
          task can become very tedious and error prone for tables,
          views, and selects with numerous columns as well as in the
          case of non-trivial data types.</li>
        <li>Free JDBC resources after interacting with the
          database, even under error conditions.</li>
      </ol>

      <p>Step (1) and (2) are for the most part trivial. Some effort
        is needed to decide the best types for each column, but once a
        good rule is decided they become easy, though tedious.</p>

      <p>The bulk of the effort is usually on step (3). The more
        columns, parameters, and non-trivial types (read BLOB, custom
        types, XML types, or other), the more expensive it gets to
        develop and test this step.</p>

      <p>Even though step (4) is not expensive to write, it&#39;s
        error prone. Inexperienced developers&mdash;and experienced too,
        unfortunately&mdash;usually do not address the error conditions
        correctly causing memory leaks in the application.</p>

      <h2>The Cost of Coding the Persistence</h2>

      <p>Now, does the advanced automation HotRod offers matter?
        Does it really save time, budget, and sleepless nights?</p>

      <p>The effort savings are clearly apparent on all but the most
        tiny applications. The savings are much more pronounced the
        bigger and more complex the application becomes&mdash;when
        complex and optimized SQL is needed.</p>

      <p>The cost of coding the persistence layer is heavily
        influenced by the natural complexity of the application being
        built and by the desired level of optimization of the database
        operations. The more complex the application (e.g. large and
        convoluted SQL, great many columns, complex data types, etc.),
        the more expensive the coding becomes. The higher the level of
        optimization (e.g. when using native database constructs, when
        dealing with massive amount of data, etc.) the more expensive
        the code also becomes.</p>

      <p>Now, in terms of cost, we can divide the persistence
        operations in the following categories:</p>

      <h3>A. Basic CRUD Operations</h3>

      <p>These are the most basic database operations that interact
        with the database tables and views. They include the typical
        select by PK, update by PK, delete by PK, and insert using
        sequences or auto-generated PKs.</p>

      <h3>B. Supplemental Operations</h3>

      <p>These are extra operations on top of the CRUD that expand
        the functionality using more advanced database metadata. They
        usually include select, update, and delete by example. They also
        leverage the database constraints to navigate the data model
        using unique constraints and foreign key relationships.</p>

      <h3>C. Regular SQL</h3>

      <p>These are standard fully fledged custom SQL statements.
        Their complexity ranges from the very simple to quite
        sophisticated, tuned, parameterized SQL selects, updates,
        deletes, and inserts that may return combined, grouped columns
        from different tables and views. They may also produce changes
        in the database using complex updates, insert, or delete
        operations. They usually include one or more of the following
        features:</p>

      <ul>
        <li>Join multiple tables and retrieve combined join data.</li>
        <li>Cleverly use indexes to optimize resources and speed up
          the operations.</li>
        <li>Include aggregate operations (group by, having).</li>
        <li>Use sub-queries.</li>
        <li>Operate on multiple/massive number of rows per SQL
          statement.</li>
        <li>Use other standard SQL features.</li>
      </ul>

      <h3>D. Native SQL</h3>

      <p>
        These are non-standard SQL statements that include
        RDBMS-specific SQL extensions. They may also be sophisticated
        and tuned parameterized SQL selects, updates, deletes, and
        inserts. They usually include one or more of the features below:<br />
        Use RDBMS-specific strategies to lock rows and/or tables.
      </p>

      <ul>
        <li>Access uncommitted table rows.</li>
        <li>Use RDBMS-specific SQL functions and/or instructions.</li>
        <li>Limit the number of returned/processed rows at the
          SQL-level.</li>
        <li>Prepare/Manage data cubes for pivoting or other.</li>
        <li>Use data warehousing functionality.</li>
        <li>Add hinting to stipulate specific SQL execution plans.</li>
        <li>Actively use table segmentation strategies.</li>
        <li>Use in-memory storage or other caching features.</li>
        <li>Create/Manage materialized data views and structures
          from existing data.</li>
        <li>Use any other non-standard SQL extensions specific to
          the RDBMS.</li>
      </ul>

      <p>These SQL statements are carefully written to optimize the
        resources and execution speed. If well written they can also
        dramatically reduce the number of network calls and latency
        needed to produce the desired data retrieval or change.</p>

      <h3>E. Dynamic SQL</h3>

      <p>These are Regular or Native SQL statements enhanced by an
        extra descriptive layer of logic that automatically alters their
        syntax and/or structure based on the parameters values received
        at runtime. Though quite exotic functionality can be achieved
        using dynamic SQL, the classic examples of it are SQL selects
        that filter rows by different columns conditions depending on
        logic related to the values of the received parameters at
        runtime, and/or sorts the rows differently depending on the
        parameter values.</p>

      <h3>F. Stored Procedures Execution</h3>

      <p>Stored procedures represent application (or multi
        application-shared) logic located in the database itself. The
        development effort to implement them is two-fold: first, the
        stored procedure itself needs to be coded into the database;
        second, Java classes need to be written to properly call and use
        this procedure, send parameters, and receive results usually in
        the form of plain values, scalars, lists, or database cursors.</p>

      <h3>G. Low-level JDBC</h3>

      <p>These SQL statements require low-level JDBC to usually
        access features such as updateable result sets, low-level
        locking, batch SQL processing, etc. Their coding becomes quite
        expensive if widely used across the application. This is usually
        needed for very optimized applications where system resources
        are very limited, or when processing very large amount of data.</p>

      <h2>HotRod Scope</h2>

      <p>HotRod automates the categories from A through E out of the
        box. Many competitor technologies tackle A and B, but rarely
        address C, D, and E. The majority of them do not automate
        complex, native, and dynamic SQL.</p>

      <p>Categories F and G have a place on optimized applications.
        Though their coding effort is considerable, they must be
        addressed when the need rises. HotRod does not offer help for
        these cases so they must be coded manually.</p>

      <p>As a general rule, simple applications tend to gravitate
        towards the usage of the first categories only, while complex
        ones use most of them. According to my personal experience, the
        chart below shows a overview of the popularity of the different
        categories on different kinds of applications. This is just
        meant as an high level overview, and may have many
        counterexamples you may have experienced, but tries to depict
        how the cost of development shifts between different kinds of
        application, or as it evolves over time as an application grows.</p>

      <img src="images/development-cost.png" width="800px;" />

      <p>From left to right the coding effort of writing the code
        manually increases. So does the potential performance that can
        be obtained from the database and JDBC. As shown in blue, HotRod
        automates the bulk of this work.</p>

      <p>Frequently, simple applications tend to use the first two
        categories since they are easier to implement and use. They tend
        to use the third, fourth, and fifth categories sparely since
        they are more expensive to develop, especially when coding
        everything manually. It&#39;s usually later when applications
        grow and have a bigger allocated budget when they devote effort
        to use more complex and optimal SQL.</p>

      <p>The chart above shows in blue the areas where HotRod
        reduces the coding effort. This is where HotRod shines. In small
        applications the savings aren&#39;t major mainly because
        there&#39;s not much to develop. In medium-sized applications
        the savings are quite significant. In large applications the
        savings become very important, even when HotRod does not
        automate the stored procedure execution or the low-level JDBC.
        In heavily optimized applications HotRod still greatly saves
        effort in the main categories, but the heavily optimized areas
        need to be tackled manually.</p>

      <h2>The Cost of Keeping the Persistence Code Up to Date</h2>

      <p>Applications necessarily change over time. Manually keeping
        the SQL and DAOs up to date when a new column is added or
        modified to a table, view, or SQL select is an error prone task.
        Fortunately HotRod makes this effort very cheap. It retrieves
        the database modified structure and updates the DAO classes and
        related files seamlessly, without losing extra logic the
        developer may have added to the persistence logic.</p>

      <p>Most competitor technologies offer the ability to retrieve
        the database changes but few of them can update the existing
        Java model and merge custom ad-hoc changes gracefully.</p>

      <p>This automated maintenance functionality becomes quite
        important for long lived applications since they allow the
        developer to effortlessly keep the application up to date over
        time for every single inescapable database change.</p>

      <p>&nbsp;</p>

      <!-- =========== -->
      <!-- Article End -->
      <!-- =========== -->

    </div>

  </div>

</body>
</html>