// Autogenerated by HotRod -- Do not edit.

package app.daos.primitives;

import java.io.Serializable;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.session.SqlSession;
import org.hotrod.runtime.cursors.Cursor;
import org.hotrod.runtime.livesql.queries.select.MyBatisCursor;

import org.hotrod.runtime.interfaces.DaoWithOrder;
import org.hotrod.runtime.interfaces.OrderBy;
import org.hotrod.runtime.interfaces.Selectable;


import app.daos.NumMODEL;

import java.sql.SQLException;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.hotrod.runtime.converter.TypeConverter;

import org.hotrod.runtime.livesql.expressions.ResultSetColumn;
import org.hotrod.runtime.livesql.dialects.SQLDialect;
import org.hotrod.runtime.livesql.metadata.NumberColumn;
import org.hotrod.runtime.livesql.metadata.StringColumn;
import org.hotrod.runtime.livesql.metadata.DateTimeColumn;
import org.hotrod.runtime.livesql.metadata.BooleanColumn;
import org.hotrod.runtime.livesql.metadata.ByteArrayColumn;
import org.hotrod.runtime.livesql.metadata.ObjectColumn;
import org.hotrod.runtime.livesql.metadata.Table;
import org.hotrod.runtime.livesql.expressions.predicates.Predicate;
import org.hotrod.runtime.livesql.metadata.AllColumns;
import org.hotrod.runtime.livesql.queries.select.CriteriaWherePhase;
import org.hotrod.runtime.livesql.metadata.View;

import org.springframework.stereotype.Component;
import org.springframework.beans.BeansException;
import org.springframework.context.annotation.Lazy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

@Component
public class Queries2DAO implements Serializable, ApplicationContextAware {

  private static final long serialVersionUID = 1L;

  @Autowired
  private SqlSession sqlSession;

  @Autowired
  private SQLDialect sqlDialect;

  private ApplicationContext applicationContext;

  @Override
  public void setApplicationContext(final ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext;
  }

  // TypeHandler for property  using Converter app.converters.DoubleConverter.

  public static class findNumbers_TotalTypeHandler implements TypeHandler<java.lang.Double> {

    private static TypeConverter<java.lang.Double, java.lang.Double> CONVERTER = new app.converters.DoubleConverter();

    @Override
    public java.lang.Double getResult(final ResultSet rs, final String columnName) throws SQLException {
      java.lang.Double value = rs.getDouble(columnName);
      if (rs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public java.lang.Double getResult(final ResultSet rs, final int columnIndex) throws SQLException {
      java.lang.Double value = rs.getDouble(columnIndex);
      if (rs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public java.lang.Double getResult(final CallableStatement cs, final int columnIndex) throws SQLException {
      java.lang.Double value = cs.getDouble(columnIndex);
      if (cs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public void setParameter(final PreparedStatement ps, final int columnIndex, final java.lang.Double v, final JdbcType jdbcType)
        throws SQLException {
      java.lang.Double value = CONVERTER.encode(v);
      if (value == null) {
        ps.setNull(columnIndex, jdbcType.TYPE_CODE);
      } else {
        ps.setDouble(columnIndex, value);
      }
    }

  }

  // TypeHandler for property  using Converter app.converters.ArrayConverter.

  public static class findNumbers_NmbsTypeHandler implements TypeHandler<java.lang.Integer[]> {

    private static TypeConverter<java.sql.Array, java.lang.Integer[]> CONVERTER = new app.converters.ArrayConverter();

    @Override
    public java.lang.Integer[] getResult(final ResultSet rs, final String columnName) throws SQLException {
      java.sql.Array value = rs.getArray(columnName);
      if (rs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public java.lang.Integer[] getResult(final ResultSet rs, final int columnIndex) throws SQLException {
      java.sql.Array value = rs.getArray(columnIndex);
      if (rs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public java.lang.Integer[] getResult(final CallableStatement cs, final int columnIndex) throws SQLException {
      java.sql.Array value = cs.getArray(columnIndex);
      if (cs.wasNull()) {
        value = null;
      }
      return CONVERTER.decode(value);
    }

    @Override
    public void setParameter(final PreparedStatement ps, final int columnIndex, final java.lang.Integer[] v, final JdbcType jdbcType)
        throws SQLException {
      java.sql.Array value = CONVERTER.encode(v);
      if (value == null) {
        ps.setNull(columnIndex, jdbcType.TYPE_CODE);
      } else {
        ps.setArray(columnIndex, value);
      }
    }

  }

  // select method: findNumbers

  /*
  * The SQL statement for this method is:


      
      
      select sum(n) as total,
             array_agg(1+2*n) as nmbs
      from generate_series(1, 5) x(n);
    

  */


  public List<NumMODEL> findNumbers() {
    return this.sqlSession.selectList("mappers.queries2DAO.select_findNumbers");
  }

}
