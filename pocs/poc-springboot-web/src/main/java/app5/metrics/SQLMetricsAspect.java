package app5.metrics;

import java.sql.PreparedStatement;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.hotrodorm.hotrod.utils.XUtil;
import org.nocrala.tools.lang.collector.listcollector.ListCollector;
import org.springframework.aop.aspectj.annotation.AspectJProxyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class SQLMetricsAspect {

  private ThreadLocal<String> sql = new ThreadLocal<String>();

  @Autowired
  private SQLMetrics sqlMetrics;

  @Around(value = "execution(* javax.sql.DataSource.getConnection())")
  public Object measureGetConnection(final ProceedingJoinPoint joinPoint) throws Throwable {
    try {
      Object conn = joinPoint.proceed();

      AspectJProxyFactory proxyFactory = new AspectJProxyFactory(conn);
      proxyFactory.addAspect(this);
      Object proxyConn = proxyFactory.getProxy();

      return proxyConn;

    } catch (Throwable e) {
      throw e;
    }
  }

  @Around(value = "execution(* java.sql.Connection.prepareStatement(..)) && args(sql)")
  public Object measurePrepareStatement(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    try {
      this.sql.set(sql);
      Object ps = joinPoint.proceed();

      AspectJProxyFactory proxyFactory = new AspectJProxyFactory(ps);
      proxyFactory.addAspect(this);
      PreparedStatement proxyPS = proxyFactory.getProxy();

      return proxyPS;

    } catch (Throwable e) {
      throw e;
    }
  }

  // java.sql.PreparedStatement declared methods

  @Around(value = "execution(* java.sql.PreparedStatement.execute(..))")
  public Object adviceExecute(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  @Around(value = "execution(* java.sql.PreparedStatement.executeLargeUpdate(..))")
  public Object adviceExecuteLargeUpdate(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  @Around(value = "execution(* java.sql.PreparedStatement.executeQuery(..))")
  public Object adviceExecExecuteQuery(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  @Around(value = "execution(* java.sql.PreparedStatement.executeUpdate(..))")
  public Object adviceExecuteUpdate(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  // java.sql.Statement declared methods

  @Around(value = "execution(* java.sql.Statement.execute(..)) && args(sql)")
  public Object adviceExecute(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.execute(..)) && args(sql, autoGeneratedKeys)")
  public Object adviceExecute(final ProceedingJoinPoint joinPoint, final String sql, final int autoGeneratedKeys)
      throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.execute(..)) && args(sql, columnIndexes)")
  public Object adviceExecute(final ProceedingJoinPoint joinPoint, final String sql, final int[] columnIndexes)
      throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.execute(..)) && args(sql, columnNames)")
  public Object adviceExecute(final ProceedingJoinPoint joinPoint, final String sql, final String[] columnNames)
      throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  // TODO Check how batches work
  @Around(value = "execution(* java.sql.Statement.executeBatch(..))")
  public Object adviceExecuteBatch(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  // TODO Check how batches work
  @Around(value = "execution(* java.sql.Statement.executeLargeBatch(..))")
  public Object adviceExecuteLargeBatch(final ProceedingJoinPoint joinPoint) throws Throwable {
    return measureSQLExecution(joinPoint, this.sql.get());
  }

  @Around(value = "execution(* java.sql.Statement.executeLargeUpdate(..)) && args(sql)")
  public Object adviceExecuteLargeUpdate(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeLargeUpdate(..)) && args(sql, autoGeneratedKeys)")
  public Object adviceExecuteLargeUpdateAK(final ProceedingJoinPoint joinPoint, final String sql,
      final int autoGeneratedKeys) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeLargeUpdate(..)) && args(sql, columnIndexes)")
  public Object adviceExecuteLargeUpdate(final ProceedingJoinPoint joinPoint, final String sql,
      final int[] columnIndexes) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeLargeUpdate(..)) && args(sql, columnNames)")
  public Object adviceExecuteLargeUpdate(final ProceedingJoinPoint joinPoint, final String sql,
      final String[] columnNames) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeQuery(..)) && args(sql)")
  public Object adviceExecuteQuery(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeUpdate(..)) && args(sql)")
  public Object adviceExecuteUpdate(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeUpdate(..)) && args(sql, autoGeneratedKeys)")
  public Object adviceExecuteUpdateAK(final ProceedingJoinPoint joinPoint, final String sql,
      final int autoGeneratedKeys) throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeUpdate(..)) && args(sql, columnIndexes)")
  public Object adviceExecuteUpdate(final ProceedingJoinPoint joinPoint, final String sql, final int[] columnIndexes)
      throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  @Around(value = "execution(* java.sql.Statement.executeUpdate(..)) && args(sql, columnNames)")
  public Object adviceExecuteUpdate(final ProceedingJoinPoint joinPoint, final String sql, final String[] columnNames)
      throws Throwable {
    return measureSQLExecution(joinPoint, sql);
  }

  private Object measureSQLExecution(final ProceedingJoinPoint joinPoint, final String sql) throws Throwable {
    long start = System.currentTimeMillis();
    try {
      Object ps = joinPoint.proceed();
      long end = System.currentTimeMillis();
      this.sqlMetrics.record(sql, end - start, null);
      return ps;

    } catch (Throwable t) {
      long end = System.currentTimeMillis();
      this.sqlMetrics.record(sql, end - start, t);
      throw t;
    }
  }

  // Helpers

  public String toString() {
    return this.getClass().getName() + "[" + System.identityHashCode(this) + "]";
  }

  // Inner classes

  @Component
  public static class SQLMetrics {

    private boolean active = true;
    private Map<String, StatementMetrics> metrics = new HashMap<String, StatementMetrics>();

    public void activate() {
      this.active = true;
    }

    public void deactivate() {
      this.active = false;
    }

    public boolean isActive() {
      return this.active;
    }

    public void record(final String sql, final long elapsedTime, final Throwable t) {
      if (this.active) {
        recordExecution(sql, elapsedTime, t);
      }
    }

    private synchronized void recordExecution(final String sql, final long elapsedTime, final Throwable t) {
      StatementMetrics sm = this.metrics.get(sql);
      if (sm == null) {
        sm = new StatementMetrics(sql);
        this.metrics.put(sql, sm);
      }
      sm.record(elapsedTime, t);
    }

    // Get stats

    public synchronized String getByHighestAvgResponseTime() {
      return this.metrics.values().stream().sorted((a, b) -> -Long.compare(a.getAverageTime(), b.getAverageTime()))
          .map(s -> "> " + s).collect(ListCollector.concat("\n"));
    }

    public synchronized String getByHighestResponseTime() {
      return this.metrics.values().stream().sorted((a, b) -> -Long.compare(a.getMaxTime(), b.getMaxTime()))
          .map(s -> "> " + s).collect(ListCollector.concat("\n"));
    }

    public synchronized String getByMostExecuted() {
      return this.metrics.values().stream()
          .sorted((a, b) -> -Long.compare(a.getTotalExecutions(), b.getTotalExecutions())).map(s -> "> " + s)
          .collect(ListCollector.concat("\n"));
    }

    public synchronized String getByMostRecentlyExecuted() {
      return this.metrics.values().stream().sorted((a, b) -> -Long.compare(a.getLastExecuted(), b.getLastExecuted()))
          .map(s -> "> " + s).collect(ListCollector.concat("\n"));
    }

    public synchronized String getByMostErrors() {
      return this.metrics.values().stream()
          .sorted((a, b) -> -Long.compare(a.getExecutionErrors(), b.getExecutionErrors())).map(s -> "> " + s)
          .collect(ListCollector.concat("\n"));
    }

    public synchronized String getErrorsByMostRecent() {
      return this.metrics.values().stream().filter(a -> a.getExecutionErrors() > 0)
          .sorted((a, b) -> -Long.compare(a.getLastExecuted(), b.getLastExecuted())).map(s -> "> " + s)
          .collect(ListCollector.concat("\n"));
    }

  }

  public static class StatementMetrics {

    private String actualSQL;
    private String compactedSQL;

    private long minTime;
    private long maxTime;

    private long totalExecutions;
    private long executionErrors;
    private long sum;
    private long sumSQ;

    private long lastExecuted;

    private long lastExceptionTimestamp;
    private Throwable lastException;

    public StatementMetrics(final String sql) {
      this.actualSQL = sql;
      this.compactedSQL = compact(sql);

      this.minTime = 0;
      this.maxTime = 0;

      this.totalExecutions = 0;
      this.executionErrors = 0;
      this.sum = 0;
      this.sumSQ = 0;

      this.lastExecuted = 0;
      this.lastExceptionTimestamp = 0;
      this.lastException = null;
    }

    public void record(final long elapsedTime, final Throwable t) {
      this.lastExecuted = System.currentTimeMillis();
      if (this.totalExecutions == 0 || elapsedTime < this.minTime) {
        this.minTime = elapsedTime;
      }
      if (this.totalExecutions == 0 || elapsedTime > this.maxTime) {
        this.maxTime = elapsedTime;
      }
      this.totalExecutions++;
      if (t != null) {
        this.executionErrors++;
        this.lastExceptionTimestamp = this.lastExecuted;
        this.lastException = t;
      }
      this.sum += elapsedTime;
      this.sumSQ += elapsedTime * elapsedTime;

    }

    public String toString() {
      String le = this.lastExecuted == 0 ? "never" : new Date(this.lastExecuted).toString();
      if (this.lastException == null) {
        return "" + this.totalExecutions + " exe" + ", " + this.executionErrors + " errors" + ", avg "
            + (this.sum / this.totalExecutions) + " ms, \u03c3 " + Math.round(this.getTimeStandardDeviation()) + " ["
            + this.minTime + "-" + this.maxTime + " ms], last executed: " + le + ", last exception: never -- "
            + this.compactedSQL;
      } else {
        return "" + this.totalExecutions + " exe" + ", " + this.executionErrors + " errors" + ", avg "
            + (this.sum / this.totalExecutions) + " ms, \u03c3 " + Math.round(this.getTimeStandardDeviation()) + " ["
            + this.minTime + "-" + this.maxTime + " ms], last executed: " + le + ", last exception at "
            + new Date(this.lastExceptionTimestamp) + ": " + XUtil.trim(this.lastException) + "\n"
            + this.compactedSQL;
      }
    }
    
    // Getters

    public String getActualSQL() {
      return actualSQL;
    }

    public String getCompactedSQL() {
      return compactedSQL;
    }

    public long getMinTime() {
      return minTime;
    }

    public long getMaxTime() {
      return maxTime;
    }

    public long getTotalExecutions() {
      return totalExecutions;
    }

    public long getExecutionErrors() {
      return executionErrors;
    }

    public long getLastExecuted() {
      return lastExecuted;
    }

    public long getLastExceptionTimestamp() {
      return lastExceptionTimestamp;
    }

    public Throwable getLastException() {
      return lastException;
    }

    // Extra getters

    public long getAverageTime() {
      return this.totalExecutions == 0 ? -1 : this.sum / this.totalExecutions;
    }

    /**
     * See Welford's online algorithm:
     * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm
     * 
     * @return the standard deviation
     */
    public double getTimeStandardDeviation() {
      return this.totalExecutions < 2 ? 0
          : Math.sqrt( //
              (this.sumSQ - 1.0 * this.sum * this.sum / this.totalExecutions) //
                  / //
                  (this.totalExecutions - 0));
    }

    // Utility

    private String compact(final String txt) {
      return txt == null ? null
          : Arrays.stream(txt.split("\n")).map(s -> s.trim()).filter(s -> !s.isEmpty())
              .collect(Collectors.joining(" "));
    }

  }

}
