The following query was run in different databases:

InvoiceTable i = InvoiceDAO.newTable("i");
BranchTable b = BranchDAO.newTable("b");

Random rand = new Random(1234);
int minAmount = 100 + rand.nextInt(500);

sql.select()
   .from(i)
   .join(b, b.id.eq(i.branchId))
   .where(b.region.eq("SOUTH").and(i.status.ne("UNPAID").and(i.amount.ge(minAmount))))
   .orderBy(i.orderDate.desc())
   .execute();

Torcs retrieved the following execution plans on each one:

# Oracle Execution Plan:

Plan hash value: 3305857414
 
----------------------------------------------------------------------------------------------
| Id  | Operation                     | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |              |     1 |   118 |     5  (20)| 00:00:01 |
|   1 |  SORT ORDER BY                |              |     1 |   118 |     5  (20)| 00:00:01 |
|   2 |   NESTED LOOPS                |              |     1 |   118 |     4   (0)| 00:00:01 |
|   3 |    NESTED LOOPS               |              |     1 |   118 |     4   (0)| 00:00:01 |
|*  4 |     TABLE ACCESS FULL         | INVOICE      |     1 |    84 |     3   (0)| 00:00:01 |
|*  5 |     INDEX UNIQUE SCAN         | SYS_C0016733 |     1 |       |     0   (0)| 00:00:01 |
|*  6 |    TABLE ACCESS BY INDEX ROWID| BRANCH       |     1 |    34 |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter("I"."STATUS"<>:2 AND "I"."AMOUNT">=:3)
   5 - access("B"."ID"="I"."BRANCH_ID")
   6 - filter("B"."REGION"=:1)
 
Note
-----
   - dynamic statistics used: dynamic sampling (level=2)


# DB2 Execution Plan:

Execution Plan: RETURN
.  144 << TBSCAN (13 rows, 37 io) 
.  .  144 SORT (13 rows, 37 io) 
.  .  |  144 HSJOIN (13 rows, 37 io) 
.  .  |  .  75 << FETCH *5 (320 rows, 19 io) INVOICE
.  .  |  .  .  27 IXSCAN (1000 rows, 4 io) SQL231114120832880 on INVOICE (+ID)
.  .  |  .  68 << FETCH *7 (40 rows, 18 io) BRANCH
.  .  |  .  .  27 IXSCAN (1000 rows, 4 io) SQL231114120832360 on BRANCH (+ID)
 
Predicates:
*5 SARG (? <= Q1.AMOUNT)
*5 SARG (Q1.STATUS <> ?)
*7 SARG (Q2.REGION = ?)
 
Legend:
<< Reads from the heap.
$ Operation is at least 20% more expensive than its combined children.


# PostgreSQL Execution Plan:

Sort  (cost=36.80..36.80 rows=1 width=221)
  Sort Key: i.order_date DESC
  ->  Hash Join  (cost=16.79..36.79 rows=1 width=221)
        Hash Cond: (i.branch_id = b.id)
        ->  Seq Scan on invoice i  (cost=0.00..19.45 rows=209 width=100)
              Filter: (((status)::text <> 'UNPAID'::text) AND (amount >= 228))
        ->  Hash  (cost=16.75..16.75 rows=3 width=121)
              ->  Seq Scan on branch b  (cost=0.00..16.75 rows=3 width=121)
                    Filter: ((region)::text = 'SOUTH'::text)

# H2 Execution Plan:

SELECT
    "I"."ID" AS "id",
    "I"."ACCOUNT_ID" AS "accountId",
    "I"."AMOUNT" AS "amount",
    "I"."BRANCH_ID" AS "branchId",
    "I"."ORDER_DATE" AS "orderDate",
    "I"."TYPE" AS "type",
    "I"."UNPAID_BALANCE" AS "unpaidBalance",
    "I"."STATUS" AS "status",
    "B"."ID" AS "id",
    "B"."REGION" AS "region",
    "B"."IS_VIP" AS "isVip"
FROM "PUBLIC"."INVOICE" "I"
    /* PUBLIC.INVOICE.tableScan */
    /* WHERE (I.AMOUNT >= ?3)
        AND (I.STATUS <> ?2)
    */
INNER JOIN "PUBLIC"."BRANCH" "B"
    /* PUBLIC.BRANCH.tableScan */
    ON 1=1
WHERE ("B"."ID" = "I"."BRANCH_ID")
    AND ("I"."AMOUNT" >= ?3)
    AND ("B"."REGION" = ?1)
    AND ("I"."STATUS" <> ?2)
ORDER BY 5 DESC
