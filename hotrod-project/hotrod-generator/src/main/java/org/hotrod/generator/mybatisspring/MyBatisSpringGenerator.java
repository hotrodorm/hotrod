package org.hotrod.generator.mybatisspring;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hotrod.config.AbstractDAOTag;
import org.hotrod.config.DisplayMode;
import org.hotrod.config.ExecutorTag;
import org.hotrod.config.HotRodConfigTag;
import org.hotrod.config.HotRodFragmentConfigTag;
import org.hotrod.config.MyBatisSpringTag;
import org.hotrod.config.TableTag;
import org.hotrod.config.ViewTag;
import org.hotrod.database.DatabaseAdapter;
import org.hotrod.exceptions.ControlledException;
import org.hotrod.exceptions.InvalidConfigurationFileException;
import org.hotrod.exceptions.InvalidIdentifierException;
import org.hotrod.exceptions.UncontrolledException;
import org.hotrod.generator.CachedMetadata;
import org.hotrod.generator.DAOType;
import org.hotrod.generator.Feedback;
import org.hotrod.generator.FileGenerator;
import org.hotrod.generator.HotRodGenerator;
import org.hotrod.generator.LiveGenerator;
import org.hotrod.generator.mybatis.DataSetLayout;
import org.hotrod.generator.mybatis.SelectAbstractVO;
import org.hotrod.generator.mybatis.SelectVO;
import org.hotrod.metadata.DataSetMetadata;
import org.hotrod.metadata.EnumDataSetMetadata;
import org.hotrod.metadata.ExecutorDAOMetadata;
import org.hotrod.metadata.SelectMethodMetadata;
import org.hotrod.metadata.SelectMethodMetadata.SelectMethodReturnType;
import org.hotrod.metadata.TableDataSetMetadata;
import org.hotrod.metadata.VOMetadata;
import org.hotrod.metadata.VORegistry.SelectVOClass;
import org.hotrod.runtime.dynamicsql.SourceLocation;
import org.hotrod.utils.ClassPackage;
import org.hotrod.utils.LocalFileGenerator;
import org.hotrod.utils.identifiers.Id;
import org.hotrod.utils.identifiers.ObjectId;
import org.nocrala.tools.database.tartarus.core.DatabaseLocation;

public class MyBatisSpringGenerator extends HotRodGenerator implements LiveGenerator {

  private static final Logger log = LogManager.getLogger(MyBatisSpringGenerator.class);

  private MyBatisSpringTag myBatisSpringTag;
  private DataSetLayout layout;

  private LinkedHashMap<DataSetMetadata, ObjectAbstractVO> abstractVos = new LinkedHashMap<DataSetMetadata, ObjectAbstractVO>();
  private LinkedHashMap<DataSetMetadata, ObjectVO> vos = new LinkedHashMap<DataSetMetadata, ObjectVO>();
  private LinkedHashMap<DataSetMetadata, ObjectDAO> daos = new LinkedHashMap<DataSetMetadata, ObjectDAO>();
  private LinkedHashMap<DataSetMetadata, Mapper> mappers = new LinkedHashMap<DataSetMetadata, Mapper>();
  private LinkedHashMap<EnumDataSetMetadata, EnumClass> enumClasses = new LinkedHashMap<EnumDataSetMetadata, EnumClass>();
  private List<ObjectAbstractVO> tableAbstractVOs = new ArrayList<ObjectAbstractVO>();
  private MyBatisConfiguration myBatisConfig;
  private LiveSQLMapper liveSQLMapper;
  private AvailableFKs availableFKs;

  private EntityDAORegistry entityDAORegistry = new EntityDAORegistry();

  public MyBatisSpringGenerator(final CachedMetadata cachedMetadata, final DatabaseLocation loc,
      final HotRodConfigTag config, final DisplayMode displayMode, final boolean incrementalMode,
      final DatabaseAdapter adapter, final Feedback feedback)
      throws UncontrolledException, ControlledException, InvalidConfigurationFileException {
    super(cachedMetadata, loc, config, displayMode, incrementalMode, adapter, feedback);
  }

  @Override
  public void prepareGeneration() throws UncontrolledException, ControlledException, InvalidConfigurationFileException {
    log.debug("prepare");

    // Load and validate the configuration file

    this.myBatisConfig = new MyBatisConfiguration(this.config);
    this.myBatisSpringTag = (MyBatisSpringTag) this.config.getGenerators().getSelectedGeneratorTag();
    this.layout = new DataSetLayout(this.config);

    // Reset the generated object counters

    this.config.resetTreeGeneratables();

    // Add tables

    for (TableDataSetMetadata tm : super.tables) {
      log.debug("tm=" + tm.getId().getCanonicalSQLName());
      addDaosAndMapper(tm, DAOType.TABLE);
      if (tm.getAutoGeneratedColumnMetadata() != null) {
        SourceLocation loc = tm.getDaoTag().getSourceLocation();
        throw new ControlledException("Invalid configuration file '" + loc.getFile().getPath() + "' (line "
            + loc.getLineNumber() + ", col " + loc.getColumnNumber()
            + "): The tag <auto-generated-column> is not supported by the MyBatis generator. "
            + "Use <column> tags with a 'sequence' attribute instead.");
      }
      for (SelectMethodMetadata sm : tm.getSelectsMetadata()) {
        addSelectVOs(sm);
      }
    }

    // Link parent tables

    for (ObjectAbstractVO avo : this.tableAbstractVOs) {
      if (avo.getMetadata().getParentMetadata() != null) {
        avo.getBundle().setParent(null);
        for (ObjectAbstractVO ovo : this.tableAbstractVOs) {
          if (avo != ovo && avo.getMetadata().getParentMetadata().getId().equals(ovo.getMetadata().getId())) {
            avo.getBundle().setParent(ovo.getBundle());
          }
        }
        if (avo.getBundle().getParent() == null) {
          throw new InvalidConfigurationFileException(avo.getMetadata().getDaoTag(),
              "Could not find parent table '" + avo.getMetadata().getParentMetadata().getId() + "' extended by table '"
                  + avo.getMetadata().getId() + "'.");
        }
      }
    }

    // Add views

    for (TableDataSetMetadata vm : super.views) {
      addDaosAndMapper(vm, DAOType.VIEW);
      for (SelectMethodMetadata sm : vm.getSelectsMetadata()) {
        addSelectVOs(sm);
      }
    }

    // Add enums

    for (EnumDataSetMetadata em : super.enums) {
      this.enumClasses.put(em,
          new EnumClass(em, new DataSetLayout(this.config), this.myBatisSpringTag.getDaos(), this));
    }

    // First-level select tags are no longer supported

    if (!super.selects.isEmpty()) {
      SourceLocation loc = super.selects.iterator().next().getDaoTag().getSourceLocation();
      throw new ControlledException("Invalid configuration in " + loc.render() + ":\n"
          + "The MyBatis generator does not support first-level <select> tags. "
          + "Include any <select> tag inside another <table>, <view>, or <dao> tag.");
    }

    // Add executors

    for (ExecutorDAOMetadata dm : super.executors) {
      addDaosAndMapper(dm, DAOType.EXECUTOR);
      for (SelectMethodMetadata sm : dm.getSelectsMetadata()) {
        addSelectVOs(sm);
      }
    }

    // Prepare the Live SQL Mapper file

    this.liveSQLMapper = new LiveSQLMapper(layout);

    // Prepare MyBatis Configuration File list

    if (this.myBatisSpringTag.getTemplate() != null) {
      this.myBatisConfig.addFacetSourceFile(this.liveSQLMapper.getFileName());
      for (Mapper mapper : this.mappers.values()) {
        String sourceFile = mapper.getRuntimeSourceFileName();
        this.myBatisConfig.addFacetSourceFile(sourceFile);
      }

      for (String sourceFile : getAllMappersSourceFileNames()) {
        this.myBatisConfig.addAnySourceFile(sourceFile);
      }
    }

    // AvailableFKs

    this.availableFKs = new AvailableFKs(this.config,
        super.tables.stream().map(t -> t.getImportedFKs()).flatMap(l -> l.stream()).collect(Collectors.toList()));

  }

  private void addDaosAndMapper(final DataSetMetadata metadata, final DAOType type) throws ControlledException {

    MyBatisSpringTag myBatisTag = (MyBatisSpringTag) this.config.getGenerators().getSelectedGeneratorTag();

    DataSetLayout layout;
    ObjectAbstractVO abstractVO;
    ObjectVO vo;
    Mapper mapper;
    ObjectDAO dao;

    Bundle bundle;

    switch (type) {

    case TABLE:
      TableTag ttag = this.config.findFacetTable(metadata, this.adapter);
      if (ttag == null) {
        throw new ControlledException(
            "Could not find table tag for table '" + metadata.getId().getCanonicalSQLName() + "'.");
      }
      layout = new DataSetLayout(this.config, ttag);

      abstractVO = new ObjectAbstractVO(metadata, layout, this, DAOType.TABLE, myBatisTag);
      this.tableAbstractVOs.add(abstractVO);
      vo = new ObjectVO(metadata, layout, this, abstractVO, myBatisTag);
      mapper = new Mapper(ttag, metadata, layout, this, type, this.adapter, vo, this.entityDAORegistry);
      dao = new ObjectDAO(ttag, metadata, layout, this, type, myBatisTag, vo, mapper);
      this.entityDAORegistry.add(vo.getFullClassName(), dao);
      mapper.setDao(dao);

      bundle = new Bundle(abstractVO, vo, dao, mapper);
      abstractVO.setBundle(bundle);
      vo.setBundle(bundle);
      mapper.setBundle(bundle);
      dao.setBundle(bundle);

      break;

    case VIEW:
      ViewTag vtag = this.config.findFacetView(metadata, this.adapter);
      if (vtag == null) {
        throw new ControlledException(
            "Could not find view tag for table '" + metadata.getId().getCanonicalSQLName() + "'.");
      }
      layout = new DataSetLayout(this.config);

      abstractVO = new ObjectAbstractVO(metadata, layout, this, DAOType.VIEW, myBatisTag);
      vo = new ObjectVO(metadata, layout, this, abstractVO, myBatisTag);
      mapper = new Mapper(vtag, metadata, layout, this, type, this.adapter, vo, this.entityDAORegistry);
      dao = new ObjectDAO(vtag, metadata, layout, this, type, myBatisTag, vo, mapper);
      this.entityDAORegistry.add(vo.getFullClassName(), dao);
      mapper.setDao(dao);

      bundle = new Bundle(abstractVO, vo, dao, mapper);
      abstractVO.setBundle(bundle);
      vo.setBundle(bundle);
      mapper.setBundle(bundle);
      dao.setBundle(bundle);

      break;

    case EXECUTOR:
      AbstractDAOTag tag = metadata.getDaoTag();
      layout = new DataSetLayout(this.config);
      abstractVO = null;
      vo = null;

      mapper = new Mapper(tag, metadata, layout, this, type, this.adapter, vo, this.entityDAORegistry);
      dao = new ObjectDAO(tag, metadata, layout, this, type, myBatisTag, vo, mapper);
      mapper.setDao(dao);

      bundle = new Bundle(abstractVO, vo, dao, mapper);
      mapper.setBundle(bundle);
      dao.setBundle(bundle);

      break;

    default:
      throw new ControlledException(
          "Unrecognized type for database object '" + metadata.getId().getCanonicalSQLName() + "'.");
    }

    if (abstractVO != null) {
      this.abstractVos.put(metadata, abstractVO);
    }
    if (vo != null) {
      this.vos.put(metadata, vo);
    }
    this.mappers.put(metadata, mapper);
    this.daos.put(metadata, dao);

  }

  private List<String> getAllMappersSourceFileNames() {

    List<String> allMappersSourceFileNames = new ArrayList<String>();

    for (TableTag t : this.config.getAllTables()) {
      ClassPackage fragmentPackage = t.getFragmentConfig() != null && t.getFragmentConfig().getFragmentPackage() != null
          ? t.getFragmentConfig().getFragmentPackage()
          : null;
      String sourceFileName = Mapper.assembleSourceFileName(layout, fragmentPackage, t.getId());
      allMappersSourceFileNames.add(sourceFileName);
    }

    for (ViewTag t : this.config.getAllViews()) {
      ClassPackage fragmentPackage = t.getFragmentConfig() != null && t.getFragmentConfig().getFragmentPackage() != null
          ? t.getFragmentConfig().getFragmentPackage()
          : null;
      String sourceFileName = Mapper.assembleSourceFileName(layout, fragmentPackage, t.getId());
      allMappersSourceFileNames.add(sourceFileName);
    }

    for (ExecutorTag t : this.config.getAllExecutors()) {
      ClassPackage fragmentPackage = t.getFragmentConfig() != null && t.getFragmentConfig().getFragmentPackage() != null
          ? t.getFragmentConfig().getFragmentPackage()
          : null;
      ObjectId id = null;
      try {
        id = new ObjectId(Id.fromJavaClass(t.getJavaClassName()));
      } catch (InvalidIdentifierException e) {
        // Ignore
      }
      String sourceFileName = Mapper.assembleSourceFileName(layout, fragmentPackage, id);
      allMappersSourceFileNames.add(sourceFileName);
    }

    return allMappersSourceFileNames;
  }

  private LinkedHashSet<SelectAbstractVO> abstractSelectVOs = new LinkedHashSet<SelectAbstractVO>();
  private LinkedHashSet<SelectVO> selectVOs = new LinkedHashSet<SelectVO>();

  private void addSelectVOs(final SelectMethodMetadata sm) throws ControlledException {

    // DataSetLayout layout = new DataSetLayout(this.config);
    HotRodFragmentConfigTag fragmentConfig = sm.getFragmentConfig();
    ClassPackage fragmentPackage = fragmentConfig != null && fragmentConfig.getFragmentPackage() != null
        ? fragmentConfig.getFragmentPackage()
        : null;
    ClassPackage daoPackage = this.layout.getDAOPackage(fragmentPackage);
    SelectMethodReturnType rt = sm.getReturnType(daoPackage);

    // solo VO

    SelectVOClass soloVO = rt.getSoloVO();
    SelectVOClass abstractSoloVO = rt.getAbstractSoloVO();

    if (soloVO != null) {
      SelectAbstractVO abstractVO = new SelectAbstractVO(abstractSoloVO, this.layout, this.myBatisSpringTag);
      this.abstractSelectVOs.add(abstractVO);
      SelectVO vo = new SelectVO(soloVO, abstractVO, this.layout);
      this.selectVOs.add(vo);
      log.trace("### soloVO.getName()=" + soloVO.getName() + " abstractVO.getName()=" + abstractVO.getName());
    }

    // connected VOs (all)

    if (sm.getStructuredColumns() != null) {
      for (VOMetadata vo : sm.getStructuredColumns().getVOs()) {
        log.trace("### Metadata: vo.getName()=" + vo.getName());
        registerVOs(vo);
      }
    }

  }

  private void registerVOs(final VOMetadata vo) {

    if (vo.getEntityVOSuperClass() != null) {

      VOClasses voc = produceVOClasses(vo);

      log.trace("@@@ x=" + voc.vo.getClassName() + " abstractVO.getName()=" + voc.abstractVO.getName());

      this.abstractSelectVOs.add(voc.abstractVO);
      this.selectVOs.add(voc.vo);

    }

    for (VOMetadata a : vo.getAssociations()) {
      this.registerVOs(a);
    }
    for (VOMetadata c : vo.getCollections()) {
      this.registerVOs(c);
    }

  }

  public VOClasses produceVOClasses(final VOMetadata vo) {
    VOClasses voc = new VOClasses();
    voc.abstractVO = new SelectAbstractVO(vo, this.layout, this.myBatisSpringTag);
    voc.vo = new SelectVO(vo, voc.abstractVO, this.layout, this.myBatisSpringTag);
    return voc;
  }

  public static class VOClasses {
    public SelectAbstractVO abstractVO;
    public SelectVO vo;
  }

  @Override // HotRodGenerator
  public void generate() throws UncontrolledException, ControlledException {
    display("");
    display("Generating MyBatis DAOs & VOs...");
    LocalFileGenerator fg = new LocalFileGenerator();
    this.generate(fg);
    display("");
    display("MyBatis generation complete.");
  }

  @Override // LiveGenerator
  public void generate(final FileGenerator fileGenerator) throws UncontrolledException, ControlledException {

    // Abstract VOs, VOs, DAOs, and Mappers for <table> & <view> tags

    for (ObjectAbstractVO abstractVO : this.abstractVos.values()) {
      abstractVO.generate(fileGenerator);
    }

    for (ObjectVO vo : this.vos.values()) {
      vo.generate(fileGenerator);
    }

    for (SelectAbstractVO avo : this.abstractSelectVOs) {
      avo.generate(fileGenerator);
    }

    for (SelectVO vo : this.selectVOs) {
      vo.generate(fileGenerator);
    }

    for (Mapper mapper : this.mappers.values()) {
      mapper.generate(fileGenerator);
    }

    for (ObjectDAO dao : this.daos.values()) {
      dao.generate(fileGenerator, this);
    }

    // TODO: Re-enable the Available FKs file.
    // this.availableFKs.generate(fileGenerator);

    // Enums

    for (EnumClass ec : this.enumClasses.values()) {
      ec.generate(fileGenerator);
    }

    // Live SQL mapper

    this.liveSQLMapper.generate(fileGenerator);

    // MyBatis Main configuration file

    if (this.myBatisSpringTag.getTemplate() != null) {
      this.myBatisConfig.generate(fileGenerator);
    }

    // compute tree generation status

    super.config.promoteTreeToGenerated();

  }

  // Getters

  public ObjectVO getVO(final DataSetMetadata dataSet) {
    return this.vos.get(dataSet);
  }

  public ObjectDAO getDAO(final DataSetMetadata dataSet) {
    return this.daos.get(dataSet);
  }

  public EnumClass getEnum(final DataSetMetadata dataSet) {
    return this.enumClasses.get(dataSet);
  }

  public Mapper getMapper(final DataSetMetadata dataSet) {
    return this.mappers.get(dataSet);
  }

  // Helpers

}
