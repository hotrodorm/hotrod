package org.hotrod.generator.mybatisspring;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hotrod.config.Constants;
import org.hotrod.config.HotRodFragmentConfigTag;
import org.hotrod.config.MyBatisSpringTag;
import org.hotrod.exceptions.ControlledException;
import org.hotrod.exceptions.UncontrolledException;
import org.hotrod.exceptions.UnresolvableDataTypeException;
import org.hotrod.generator.DAOType;
import org.hotrod.generator.FileGenerator;
import org.hotrod.generator.FileGenerator.TextWriter;
import org.hotrod.generator.GeneratableObject;
import org.hotrod.metadata.ColumnMetadata;
import org.hotrod.metadata.DataSetMetadata;
import org.hotrod.runtime.spring.LazyParentClassLoading;
import org.hotrod.utils.ClassPackage;
import org.nocrala.tools.lang.collector.listcollector.ListWriter;

public class ObjectAbstractVO extends GeneratableObject {

  private static final Logger log = LogManager.getLogger(ObjectAbstractVO.class);

  private DataSetMetadata metadata;
  private DataSetLayout layout;
  private MyBatisSpringGenerator generator;
  private DAOType daoType;
  private MyBatisSpringTag myBatisTag;
  private HotRodFragmentConfigTag fragmentConfig;
  private ClassPackage fragmentPackage;

  private ClassPackage classPackage;

  private TextWriter w;

  private String parentDAOProperty;
  private String parentVOProperty;

  // Constructor

  public ObjectAbstractVO(final DataSetMetadata metadata, final DataSetLayout layout,
      final MyBatisSpringGenerator generator, final DAOType daoType, final MyBatisSpringTag myBatisTag) {
    super();
    log.debug("init");

    this.metadata = metadata;
    this.layout = layout;
    this.generator = generator;
    if (daoType == null) {
      throw new RuntimeException("VOType cannot be null.");
    }
    metadata.getDaoTag().addGeneratableObject(this);
    this.daoType = daoType;
    this.myBatisTag = myBatisTag;
    this.fragmentConfig = metadata.getFragmentConfig();
    this.fragmentPackage = this.fragmentConfig != null && this.fragmentConfig.getFragmentPackage() != null
        ? this.fragmentConfig.getFragmentPackage()
        : null;

    this.classPackage = this.layout.getDAOPrimitivePackage(this.fragmentPackage);
  }

  // Getters

  public void generate(final FileGenerator fileGenerator) throws UncontrolledException, ControlledException {

    String className = this.getClassName() + ".java";

    File dir = this.layout.getDaoPrimitivePackageDir(this.fragmentPackage);

    File f = new File(dir, className);

    this.w = null;

    try {
      this.w = fileGenerator.createWriter(f);

      writeClassHeader();

      writeProperties();

      writeGettersAndSetters();

      writeToString();

      writeToJSON();

      writePropertiesChangeLog();

      writeClassFooter();

      super.markGenerated();

    } catch (IOException e) {
      throw new UncontrolledException(
          "Could not generate DAO primitives class: could not write to file '" + f.getName() + "'.", e);
    } catch (UnresolvableDataTypeException e) {
      throw new ControlledException("Could not generate DAO primitives for table '" + e.getTableName()
          + "'. Could not handle columns '" + e.getColumnName() + "' type: " + e.getTypeName());
    } finally {
      if (this.w != null) {
        try {
          this.w.close();
        } catch (IOException e) {
          throw new UncontrolledException(
              "Could not generate DAO primitives class: could not close file '" + f.getName() + "'.", e);
        }
      }
    }

  }

  private void writeClassHeader() throws IOException {

    // Comment

    println("// Autogenerated by " + Constants.TOOL_NAME + " -- Do not edit.");
    println();

    // Package

    println("package " + this.classPackage.getPackage() + ";");
    println();

    // Imports

    println("import java.io.Serializable;");
    println("import org.hotrod.runtime.json.*;");
    if (this.getBundle().getParent() != null) {
      println("import org.springframework.beans.factory.annotation.Autowired;");
      println("import " + this.getBundle().getParent().getVO().getFullClassName() + ";");
      println("import " + LazyParentClassLoading.class.getName() + ";");
    }
    println();

    // Signature

    if (this.getBundle().getParent() != null) {
      println("public class " + this.getClassName() + " implements " + LazyParentClassLoading.class.getSimpleName()
          + ", Serializable {");
    } else {
      println("public class " + this.getClassName() + " implements Serializable {");
    }

    println();

    // Serial Version UID

    println("  private static final long serialVersionUID = 1L;");
    println();

  }

  private void writeProperties() throws IOException, UnresolvableDataTypeException {

    println("  // VO Properties ("
        + (this.daoType == DAOType.TABLE ? "table" : this.daoType == DAOType.VIEW ? "view" : "select") + " columns)");
    println();
    writeColumnProperties(this.metadata.getColumns());

    // add parent DAO & VO if it extends another table

    log.debug("" + this.metadata.getId() + ": this.metadata.getParentMetadata()=" + this.metadata.getParentMetadata());

    if (this.getBundle().getParent() != null) {
      println("  // Parent DAO and VO (since this table extends another one)");
      println();

      String daoClassName = this.getBundle().getParent().getDAO().getClassName();
      this.parentDAOProperty = this.toLowerInitial(daoClassName);
      println("  @Autowired");
      println("  private " + daoClassName + " " + this.parentDAOProperty + " = null;");

      println();
      String voClassName = this.getBundle().getParent().getVO().getClassName();
      this.parentVOProperty = this.toLowerInitial(voClassName);
      println("  private " + voClassName + " " + this.parentVOProperty + " = null;");
      println();
    }

  }

  private void writeColumnProperties(List<ColumnMetadata> columns) throws IOException {
    for (ColumnMetadata cm : columns) {
      String javaType = resolveType(cm);
      println("  protected " + javaType + " " + cm.getId().getJavaMemberName() + " = null;");
    }
    println();
  }

  private String resolveType(final ColumnMetadata cm) {
    EnumClass ec = this.generator.getEnum(cm.getEnumMetadata());
    return ec != null ? ec.getFullClassName() : cm.getType().getJavaClassName();
  }

  private void writeGettersAndSetters() throws IOException, UnresolvableDataTypeException {

    if (this.getBundle().getParent() != null) { // table that extends another one

      ColumnMetadata pkm = this.metadata.getPK().getColumns().get(0);
      {

        println("  // PK getters & setters");
        println();

        String javaType = resolveType(pkm);
        String m = pkm.getId().getJavaMemberName();
        writeGetter(pkm, javaType, m);

        String setter = pkm.getId().getJavaSetter();
        println("  public void " + setter + "(final " + javaType + " " + m + ") {");
        println("    this.unloadSuperclass();");
        println("    this." + m + " = " + m + ";");
        println("  }");

        println();
        println("  @Override");
        println("  public boolean isLoaded() {");
        println("    return this." + this.parentVOProperty + " != null;");
        println("  }");
        println();
        println("  @Override");
        println("  public void unloadSuperclass() {");
        println("    System.out.println(\">>> Unloading superclass...\");");
        println("    this." + this.parentVOProperty + " = null;");
        println("  }");
        println();
        println("  @Override");
        println("  public void loadSuperclass() {");
        println("    if (!this.isLoaded()) {");
        println("      System.out.println(\">>> Loading superclass\");");
        println("      this." + this.parentVOProperty + " = this." + this.parentDAOProperty + ".selectByPK(this." + m
            + ");");
        println("    }");
        println("    else");
        println("      System.out.println(\">>>Nothing to do...already loaded\");");
        println("  }");
        println();
      }

      println("  // Non-PK getters & setters");
      println();

      for (ColumnMetadata cm : this.metadata.getNonPkColumns()) {
        String javaType = resolveType(cm);
        String m = cm.getId().getJavaMemberName();
        writeGetter(cm, javaType, m);
        writeSetter(cm, javaType, m);
      }

      println("  // Parent getters & setters");
      println();
      for (ColumnMetadata cm : this.metadata.getParentMetadata().getNonPkColumns()) {
        String javaType = resolveType(cm);
        String m = cm.getId().getJavaMemberName();
        writeParentGetter(cm, javaType, m);
        writeParentSetter(cm, javaType, m);
      }

    } else { // traditional table without extends

      println("  // getters & setters");
      println();

      for (ColumnMetadata cm : this.metadata.getColumns()) {
        String javaType = resolveType(cm);
        String m = cm.getId().getJavaMemberName();
        writeGetter(cm, javaType, m);
        writeSetter(cm, javaType, m);
      }

    }

  }

  private void writeGetter(ColumnMetadata cm, String javaType, String m) throws IOException {
    println("  public " + javaType + " " + cm.getId().getJavaGetter() + "() {");
    println("    return this." + m + ";");
    println("  }");
    println();
  }

  private void writeSetter(final ColumnMetadata cm, final String javaType, final String m) throws IOException {
    String setter = cm.getId().getJavaSetter();
    println("  public void " + setter + "(final " + javaType + " " + m + ") {");
    println("    this." + m + " = " + m + ";");
    String name = cm.getId().getJavaMemberName() + "WasSet";
    println("    this.getPropertiesChangeLog()." + name + " = true;");
    println("  }");
    println();
  }

  private void writeParentGetter(ColumnMetadata cm, String javaType, String m) throws IOException {
    println("  public " + javaType + " " + cm.getId().getJavaGetter() + "() {");
    println("    return this." + this.parentVOProperty + "." + cm.getId().getJavaGetter() + "();");
    println("  }");
    println();
  }

  private void writeParentSetter(final ColumnMetadata cm, final String javaType, final String m) throws IOException {
    String setter = cm.getId().getJavaSetter();
    println("  public void " + setter + "(final " + javaType + " " + m + ") {");
    println("    this." + this.parentVOProperty + "." + setter + "(" + m + ");");
    println("  }");
    println();
  }

  private void writeToString() throws IOException, UnresolvableDataTypeException {
    println("  // to string");
    println();

    println("  public String toString() {");
    println("    java.lang.StringBuilder sb = new java.lang.StringBuilder();");

    if (this.myBatisTag.getProperties().isMultilineTostring()) {
      println("    sb.append( getClass().getName() + '@' + Integer.toHexString(hashCode()) + \"\\n\");");

      String prefix = "";
      String elemPrefix = "    sb.append(";
      String elemSuffix = "";
      String separator = " + \"\\n\");\n";
      String lastSeparator = separator;
      String suffix = ");";
      ListWriter lw = new ListWriter(prefix, elemPrefix, elemSuffix, separator, lastSeparator, suffix);
      for (ColumnMetadata cm : this.metadata.getColumns()) {
        String prop = cm.getId().getJavaMemberName();
        lw.add("\"- " + prop + "=\" + this." + prop);
      }
      println(lw.toString());

    } else {
      println("    sb.append(\"[\");");

      String prefix = "";
      String elemPrefix = "    sb.append(";
      String elemSuffix = "";
      String separator = " + \", \");\n";
      String lastSeparator = separator;
      String suffix = ");";
      ListWriter lw = new ListWriter(prefix, elemPrefix, elemSuffix, separator, lastSeparator, suffix);
      for (ColumnMetadata cm : this.metadata.getColumns()) {
        String prop = cm.getId().getJavaMemberName();
        lw.add("\"" + prop + "=\" + this." + prop);
      }
      println(lw.toString());

      println("    sb.append(\"]\");");
    }

    println("    return sb.toString();");
    println("  }");
    println();

  }

  private void writeToJSON() throws IOException, UnresolvableDataTypeException {
    println("  // to JSON");
    println();

    println("  public String toJSON() {");
    println("    JSONObject obj = new JSONObject();");

    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String prop = cm.getId().getJavaMemberName();
      println("    obj.addProperty(\"" + prop + "\", " + "this." + prop + ");");
    }

    println("    return obj.render();");
    println("  }");
    println();
  }

  /**
   * <pre>
   * // Properties change log
   * 
   * private PropertiesChangeLog propertiesChangeLog = new PropertiesChangeLog();
   * 
   * public class PropertiesChangeLog {
   *   boolean idWasSet = false;
   *   boolean nameWasSet = false;
   *   boolean typeWasSet = false;
   *   boolean currentBalanceWasSet = false;
   *   boolean createdOnWasSet = false;
   * }
   * </pre>
   * 
   * @throws IOException
   */
  private void writePropertiesChangeLog() throws IOException {
    println("  // Properties change log");
    println();
    println("  private PropertiesChangeLog propertiesChangeLog = new PropertiesChangeLog();");
    println();
    println("  protected PropertiesChangeLog getPropertiesChangeLog() {");
    println("    return propertiesChangeLog;");
    println("  }");
    println();
    println("  protected class PropertiesChangeLog {");

    for (ColumnMetadata cm : this.metadata.getColumns()) {
      String name = cm.getId().getJavaMemberName() + "WasSet";
      println("    public boolean " + name + " = false;");
    }

    println("  }");
    println();

  }

  private void writeClassFooter() throws IOException {
    println("}");
  }

  DataSetMetadata getMetadata() {
    return metadata;
  }

  // Identifiers & File Paths

  public String getFullClassName() {
    return this.classPackage.getFullClassName(getClassName());
  }

  public String getClassName() {
    return this.myBatisTag.getDaos().generateAbstractVOName(this.metadata.getId());
  }

  // Helpers

  private String toLowerInitial(final String txt) {
    if (txt == null || txt.length() < 1) {
      return txt;
    }
    return txt.substring(0, 1).toLowerCase() + txt.substring(1);
  }

  @SuppressWarnings("unused")
  private void print(final String txt) throws IOException {
    this.w.write(txt);
  }

  private void println(final String txt) throws IOException {
    this.w.write(txt);
    println();
  }

  private void println() throws IOException {
    this.w.write("\n");
  }

}
