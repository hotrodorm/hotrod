## Graph Selects

Graph Selects enhance the flat select model by adding a structure to the result set. Instead of
a list of VOs, these queries can return more complex data structures such as tuples of VOs or
graphs of VOs.

Each member of the data structure has fully named and fully typed properties. The resulting data
structure is configured by a tag structure defined in the query.

The main difference between a Flat Select and a Graph Select is that instead of a flat list of columns 
in the `SELECT` clause, the graph select includes a `<columns>` tag that defines an enhanced data 
structure.


## Example

The following query joins several tables to produce a result set of rows. The persistence layer receives the
data rows and automatically combines them into a list of trees of VOs. The tree structure is defined with
nested `<collection>` and `<association>` tags:

```xml
<select method="retrieveOrderProducts">
  <parameter name="categoryId" java-type="Integer" />
  select
    <columns>
      <vo table="orders" extended-vo="OrderWithProductsVO" alias="o">
        <collection table="product" property="products" alias="p" />
        <association table="region" property="region" alias="r" />
      </vo>
    </columns>
  from orders o
  join region r on o.region_id = r.id
  join order_product op on op.order_id = o.id
  join product p on p.product_id = op.product_id
  where p.category_id = #{categoryId}
  order by o.id
</select>
```

The query leverages the existing VOs (`ProductVO` and `RegionVO`) of the CRUD model and creates new VOs as
needed (`OrderWithProductsVO`) by the data graph.

Because `product` is marked as a *collection* each `OrderWithProductsVO` includes a of `List<ProductVO>`. On
the flip side since `region` is marked as an *association* each `OrderWithProductsVO` includes a single 
`RegionVO`. The Java method generated by this query looks like:

```java
public List<OrderWithProductsVO> retrieveOrderProducts(Integer categoryId) { ... }
```

Notice there may not be a 1:M relationship between the entities `orders` and `product` in the database. However, 
according to the logic of this query they are considered to have this 1:M relationship and the resulting graph
is modeled accordingly.


## Parameters

Graph selects follow the same rules as flat Selects. They use the `<parameter>` and `<complement>` tags in the same way. 
See [Query Parameters](nitro-parameters.md) for details and examples.  


## Value Object Modeling

HotRod models VOs using two classes to allow the developer to add custom behavior to the value
objects while allowing automatic structure updates at the same time. See 
[Value Object Modeling](../crud/value-object-modeling.md) for details.


## Native SQL

All native SQL statements are supported to take full advantage of the database dialect features.


## Dynamic SQL

Graph selects can be enhanced with [Dynamic SQL](nitro-dynamic-sql.md). Dynamic SQL allows the query to 
include, exclude, or render fragments of the SQL statement at runtime based on the values of the runtime
parameters.


## Query Return Mode

Unlike Flat Selects, Graph selects only return lists of graphs. The return mode is not selectable.


## Types of Graph Selects

By assembling different inner tags the `<columns>` tag can produce different variations for graph selects:

- [Single VOs per Row](./single-vo-per-row.md).
- [Multiple VOs per Row](./multiple-vos-per-row.md).
- [Extra Expressions](./extra-expressions.md).
- [Collections](./collections.md).
- [Nested Collections](./nested-collections.md).
- [Associations](./associations.md).
- [Combining Collections and Associations](./combining-collections-and-associations.md).
- [Combining All Features](./combining-all-features.md).






