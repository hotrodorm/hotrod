# LiveSQL Subqueries

Since its inception in version 3.0 LiveSQL has included a subset of the subqueries syntax for a
limited number of cases. Starting in version 4.1 LiveSQL now offers a full syntax that
covers most of the common and heavily syntax for subqueries.

## Overview

The implementation of SQL subqueries changes dramatically in version 4.1.

### LiveSQL 3.0

LiveSQL implements subqueries since version 3.0, although limited to a few specific cases. They are available for:

- **IN/NOT IN Operators**: These operators filter data by checking if a column, value or expression is included or excluded in a list
generated by a subquery.

- **EXISTS/NOT EXISTS Operators**: These operators filter data by checking if at least one row
(with any value or nulls) is generated by subquery. This subquery can be plain or correlated
to the main query.

- **Assymmetric Operators**: These operators filter data by comparing scalar values against sets of values generated by a subquery. This subquery
can be plain or correlated to the main query. Assymmetric operators combine the traditional operators `=`, `<>`, `<`, `>`, `<=`, `>=` by appending the extra clauses `ALL` or `ANY` to them. Note that `IN` and `NOT IN` are also assymmetric operators (equivalent to `= ANY` and `<> ALL` respectively) that were defined separately because of their relevance.

### LiveSQL 4.1 (unreleased)

The addition of the following types of subqueries greatly enhances the syntax of LiveSQL, to
produce powerful, complex queries.
It includes:

- **Scalar Subqueries**: Scalar Subqueries are subqueries that return a single value. They are 
typically used to produce values in the select list (or in other parts of the query) that are 
computed by a query that needs to access system data, related tables, or unrelated tables.

- **Table Expressions**: This is the most common type of subqueries that include the full syntax a `SELECT` statement. They are also known as *Derived Tables* or *Inline Views*. They can be included in the `FROM` and `JOIN` clauses and also allow nesting of subqueries as
allowed by the SQL Standard.

- **Common Table Expressions (CTEs)**: Common Table Expressions greatly simplify the use and reuse of table expressions by naming them in advance, and using them later. Plain and recursive CTEs  are implemented.

- **Lateral Joins**: Inner and outer lateral joins are implemented. Since not all database engines support them LiveSQL limits its use to specific engines and specific versions of them. In short, LiveSQL support lateral joins for the following databases:
    - Oracle 12c1 or newer
    - DB2 LUW 10.5 or newer
    - PostgreSQL 9.3 or newer
    - SQL Server 2014 or newer
    - MySQL 8.0.14 or newer

### LiveSQL Subqueries Are Not Materialized

Even though subqueries are used in a very similar way as tables and views, they are treated differently by LiveSQL. Since the structure of tables and views is retrieved from the database in advance, their column names and types are fully known by LiveSQL.

For example, if the table `CLIENT` has a column named `BRANCH_ID` LiveSQL can conveniently use this column as `c.branchId` in the LiveSQL query definition, and the Java compiler conveniently checks their existence and type, an also offers specific operators and functions to use accordingly.

On the other hand subqueries do produce on-the-fly columns but these are unknown to LiveSQL in advance and cannot be checked by the Java compiler while writing the query. In short, subquery columns are not ***materialized***.

Therefore, to refer to a non-materialized subquery column in an outer scope LiveSQL includes six methods:

- `.num("columnName")` to reference a numeric column of a subquery.
- `.str("columnName")` to reference a string/varchar column of a subquery.
- `.dt("columnName")` to reference a date/time column of a subquery.
- `.bool("columnName")` to reference a boolean column of a subquery.
- `.bin("columnName")` to reference a binary column of a subquery.
- `.obj("columnName")` to reference an object column of a subquery.

It's up to the developer to ensure the appropriate method is used to retrieve each subquery column with the appropriate type. Without subquery materialization LiveSQL has no means to check if the type of the column is appropriate, or if the name of the column is correct.

## Examples

The following examples illustrate the different types of subqueries. Each one includes the LiveSQL code and the corresponding SQL query that is run in the database.

### 1. IN/NOT IN Operators

The following query uses the `NOT IN` operator:

```sql
SELECT *
FROM account
WHERE branch_id NOT IN (
  SELECT id FROM branch WHERE region = 'SOUTH'
)
```

Using the method `.notIn(<subquery>)` it can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

List<Row> rows = sql.select()
    .from(a)
    .where(a.branchId.notIn(
        sql.select(b.id).from(b).where(b.region.eq("SOUTH"))
    ))
    .execute();
```

**Variation Using Tuples**

In some databases the `IN/NOT IN` operator can also accept tuples. The following query shows how tuples can be used this way.

```sql
SELECT *
FROM employee
WHERE (type, region) NOT IN (
  select type, region from codes where active = 1
)
```

Tuples can be used in LiveSQL using the `sql.tuple()` method that accept one or more elements in it. The example above can be written in LiveSQL as:

```java
EmployeeTable e = EmployeeDAO.newTable("e");
CodesTable c = CodesDAO.newTable("c");

List<Row> rows = sql
    .select()
    .from(e)
    .where(sql.tuple(e.type, e.region).notIn(
      sql.select(c.type, c.region).from(c).where(c.active.eq(1))
    ))
    .execute();
```

**Note**: Tuples are implemented for the `IN/NOT IN` operators in the Oracle, DB2 LUW, PostgreSQL, MySQL, MariaDB, H2 (version 2+), and HyperSQL databases. At the time of this writing SQL Server, Sybase/SAP ASE, and Apache Derby do not support them.

### 2. EXISTS/NOT EXISTS Operators

The following query uses the `NOT EXISTS` operator:

```sql
SELECT *
FROM account a
WHERE NOT EXISTS (
  SELECT 1 FROM branch b WHERE b.id = a.branch_id AND b.region = 'SOUTH'
)
```

Using the method `.notExists(<subquery>)` it can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

List<Row> rows = sql.select()
    .from(a)
    .where(sql.notExists(
      sql.select(sql.val(1)).from(b).where(b.id.eq(a.branchId).and(b.region.eq("SOUTH")))
    ))
    .execute();
```

### 3. Assymmetric Operators

Assymmetric operators compare a single value &mdash; a scalar or a tuple &mdash; with a set of values produced by a subquery. They combine the traditional operators `=`, `<>`, `<`, `>`, `<=`, `>=` with the extra clauses `ALL` or `ANY`.

The following query uses the `> ANY` operator:

```sql
SELECT *
FROM invoice i
WHERE i.unpaid_balance > ANY (
  SELECT x.amount * 0.5 FROM invoice x WHERE x.account_id = i.account_id
)
```

Using the method `.gtAny(<subquery>)` it can be written in LiveSQL as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceTable x = InvoiceDAO.newTable("x");

List<Row> rows = sql.select()
    .from(i)
    .where(i.unpaidBalance.gtAny(
      sql.select(x.amount.mult(0.5)).from(x).where(x.accountId.eq(i.accountId))
    ))
    .execute();
```

### 4. Scalar Subqueries

Scalar subqueries evaluate to a single *scalar* value. They can appear in any place where a value
can be included in the query; typically they are placed in the select list, but can be placed 
anywhere in the query. The following query includes two scalar subqueries:


```sql
SELECT
  i.*,
  50 + (SELECT max(amount) FROM payment WHERE amount < 1000) / 2 AS "score",
  (SELECT max(b.status) FROM invoice b WHERE b.account_id = i.account_id AND b.id <> i.id)
    || '/C' AS "maxStatus"
FROM invoice i
WHERE i.status = 'UNPAID'

```

Using `sql.selectScalar()` the query can be written as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceTable b = InvoiceDAO.newTable("b");
PaymentTable p = PaymentDAO.newTable("p");

List<Row> rows = sql.select(
    i.star(),
    sql.val(50).plus(sql.selectScalar(sql.max(p.amount)).from(p).where(p.amount.lt(1000)).div(2)).as("score"),
    sql.selectScalar(sql.max(b.status)).from(b).where(b.accountId.eq(i.accountId).and(b.id.ne(i.id)))
      .concat("/C").as("maxStatus"))
  .from(i)
  .where(i.status.eq("UNPAID"))
  .execute();
```

**Notes**:

- The first scalar subquery takes the place of a number. As such it's divided by 2 and then it's added the value 50.
- The first scalar subquery is not correlated; the second one is since its value depends on the driving table.
- Depending on the parameter value, the type of the scalar subquery can be any of the six core types of LiveSQL. Namely: number, string, boolean, date/time, binary, and object. In this case the first one produces a number, and the second scalar subquery produces a string value.
- A scalar subquery can only produce a single column, not two or more.
- A scalar subquery must generate one row at the most. If more rows are generated, the whole query will fail with an error. If zero rows are generated the scalar subquery evaluates to null.

### 5. Table Expressions

Table Expressions can take the place of a table or view in a query. They can be joined to other table expressions and they can also be nested as needed to write more complex logic.

**5.1 Using One Table Expression**

The following query joins a table with a table expression:

```sql
SELECT a.id, a.branch_id, x.total
FROM account a
JOIN (
  SELECT i.account_id, p.id, sum(l.line_total) AS total
  FROM invoice i
  JOIN invoice_line l ON l.invoice_id = i.id
  JOIN product p ON p.id = l.product_id
  WHERE p.type = 'OTC'
  GROUP BY i.account_id, p.id
) x ON x.account_id = a.id
WHERE x.total > 1000
```

In LiveSQL the table expression `x` is defined first, and the it takes the place of a traditional
table in the `from()` or `join()` clauses:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x",
    sql.select(i.accountId, p.id, sql.sum(l.lineTotal).as("total"))
        .from(i)
        .join(l, l.invoiceId.eq(i.id))
        .join(p, p.id.eq(l.productId))
        .where(p.type.eq("OTC"))
        .groupBy(i.accountId, p.id)
);
List<Row> rows = sql.select(a.id, a.branchId, x.num("total"))
    .from(a)
    .join(x, x.num("accountId").eq(a.id))
    .where(x.num("total").gt(1000))
    .execute();
```

**5.2 Nesting Table Expressions**

The following query nests one table expression into another one:

```sql
SELECT
  y.grp,
  min(y.order_date) AS start,
  sum(y.unpaid_balance) AS group_balance
FROM (
  SELECT
    x.order_date,
    x.unpaid_balance,
    sum(x.inc) over(partition by x.id order by x.order_date) AS grp
  FROM (
    SELECT
      i.order_date,
      i.unpaid_balance,
      case when (i.type <> lag(i.type) over(partition by i.id order by i.order_date)) then 1 else 0 end AS inc
    FROM invoice i
    WHERE i.account_id = 1015
  ) x
) y
GROUP BY y.grp
```

It can be written in LiveSQL as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x",
    sql.select(
        i.orderDate,
        i.unpaidBalance,
        sql.caseWhen(i.type.ne(sql.lag(i.type).over().partitionBy(i.id).orderBy(i.orderDate.asc()).end()), 1)
            .elseValue(0).end().as("inc"))
        .from(i)
        .where(i.accountId.eq(1015))
);
Subquery y = sql.subquery("y",
    sql.select(
        x.dt("orderDate"),
        x.num("unpaidBalance"),
        sql.sum(x.num("inc")).over().partitionBy(x.num("id")).orderBy(x.dt("orderDate").asc()).end().as("grp"))
        .from(x)
);
List<Row> rows = sql.select(
    y.num("grp"),
    sql.min(y.dt("orderDate")).as("start"),
    sql.sum(y.num("unpaidBalance")).as("groupBalance"))
  .from(y)
  .groupBy(y.num("grp"))
  .execute();
```

**5.3 Joining Table Expressions**

Any number of table expressions can participate in a query. The following example
joins two table expressions:

```sql
SELECT x.is_vip, x.id, x.branch_id
FROM (
  SELECT b.is_vip, a.id, a.branch_id
  FROM branch b
  JOIN account a ON a.branch_id = b.id
) x
LEFT JOIN (
  SELECT i.account_id
  FROM invoice i
  JOIN invoice_line l ON l.invoice_id = i.id
  JOIN product p ON p.id = l.product_id
  WHERE p.shipping = 0
) y ON y.account_id = x.id
WHERE y.account_id is null
```

It can be written in LiveSQL as:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x",
    sql.select(b.isVip, a.star())
        .from(b)
        .join(a, a.branchId.eq(b.id))
);
Subquery y = sql.subquery("y",
    sql.select(i.accountId)
        .from(i)
        .join(l, l.invoiceId.eq(i.id))
        .join(p, p.id.eq(l.productId))
        .where(p.shipping.eq(0)));
List<Row> rows = sql.select(x.star())
    .from(x)
    .leftJoin(y, y.num("accountId").eq(x.num("id")))
    .where(y.num("accountId").isNull())
    .execute();
```


**5.4 Naming the Columns of a Table Expression**

The names of the resulting columns can be named in a table expression right after its name.

In the following example the columns of the table expression `x` are named `vip` and `aid` respectively:

```sql
SELECT x.vip, x.aid
FROM (
  SELECT b.is_vip, a.id,
  FROM branch b
  JOIN account a ON a.branch_id = b.id
) x (vip, aid)
WHERE x.vip = 1
```

It can be written in LiveSQL as:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");

Subquery x = sql.subquery("x", "vip", "aid")
    .as(
      sql.select(b.isVip, a.id)
        .from(b)
        .join(a, a.branchId.eq(b.id))
    );
List<Row> rows = sql.select(x.num("vip"), x.str("aid"))
    .from(x)
    .where(x.num("vip").eq(1))
    .execute();
```

**Note**: Oracle and MariaDB do not support externally naming the columns of a table expression. You can still use `.as()` in the subquery select list to name the columns.

### 6. Common Table Expressions (CTEs)

Common Table Expressions are subqueries defined separately before the main query, so they can be used in the main query one or more times. Moreover, any CTE can use any previously defined CTEs, in the order they are defined effectively reusing them, something that a traditional table expression cannot do.

For example, the query above can also be written with CTEs. It takes the form:

```sql
WITH
x AS (
  SELECT b.is_vip, a.id, a.branch_id
  FROM branch b
  JOIN account a ON a.branch_id = b.id
),
y (aid) AS (
  SELECT i.account_id
  FROM invoice i
  JOIN invoice_line l ON l.invoice_id = i.id
  JOIN product p ON p.id = l.product_id
  WHERE p.shipping = 0
)
SELECT x.is_vip, x.id, x.branch_id
FROM x
LEFT JOIN y ON y.aid = x.id
WHERE y.aid is null
```

It can be written in LiveSQl as:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

CTE x = sql.cte("x",
    sql.select(b.isVip, a.star())
        .from(b)
        .join(a, a.branchId.eq(b.id))
);
CTE y = sql.cte("y", "aid").as(sql.select(i.accountId)
    .from(i)
    .join(l, l.invoiceId.eq(i.id))
    .join(p, p.id.eq(l.productId))
    .where(p.shipping.eq(0)));
List<Row> rows = sql.with(x, y)
    .select(x.star())
    .from(x)
    .leftJoin(y, y.num("aid").eq(x.num("id")))
    .where(y.num("aid").isNull())
    .execute();
```

Note that the first CTE does not alias its columns, but the second one does. That means that the first one assumes the column names directly from the subquery.

### 7. Recursive Common Table Expressions (Recursive CTEs)

Recursive CTEs can be expressed in LiveSQL. Since the query definition references itself they
need to be defined in two steps.

The following query retrieves the account 1215 with all its subaccounts, and then gets the amounts
of all the invoices related to them:

```sql
WITH RECURSIVE
g AS ( -- first, the anchor term
  SELECT id FROM account WHERE id = 1215
 UNION ALL -- then, the recursive term
  SELECT b.id
  FROM g
  JOIN account b ON b.parent_id = g.id
)
SELECT g.id, i.amount
FROM g
JOIN invoice i ON i.account_id = g.id
```

This query can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
AccountTable b = AccountDAO.newTable("b");
InvoiceTable i = InvoiceDAO.newTable("i");

RecursiveCTE g = sql.recursiveCTE("g");
g.as(
  sql.select(a.id)
    .from(a)
    .where(a.id.eq(1215))
  ,
  sql.select(b.id)
    .from(g)
    .join(b, b.parentId.eq(g.num("id")))
);

List<Row> rows = sql.with(g)
    .select(g.num("id"), i.amount)
    .from(g)
    .join(i, i.accountId.eq(g.num("id")))
    .execute();
```

Notice the use of the `.as(anchorTerm, recursiveTerm)` method. It specifies the anchor and recursive
terms of the recursive CTE separately. `UNION ALL` is the default linking operator.

There's the alternative method `.asUnion(anchorTerm, recursiveTerm)` that implements recursive CTEs using the `UNION` operator rather than the default `UNION ALL` operator. This variant is only supported by the PostgreSQL and MariaDB databases.

### 8. Lateral Joins

Lateral joins are executed once per each row of the previous tables or table
expression. Lateral joins can operate as inner or outer joins.

The following example shows both types:

```sql
SELECT a.*, x.*, y.*
FROM account a
JOIN LATERAL (
  SELECT i.order_date
  FROM invoice i
  WHERE i.account_id = a.id
  ORDER BY i.order_date desc
  LIMIT 2
) x ON true
LEFT JOIN LATERAL (
  SELECT p.payment_date AS last_payment
  FROM payment p
  WHERE p.invoice_id = a.id
  ORDER BY p.payment_date desc
  LIMIT 1
) y ON true
WHERE a.branch_id = 1014
```

This query can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
PaymentTable p = PaymentDAO.newTable("p");

Subquery x = sql.subquery("x",
    sql.select(i.orderDate)
        .from(i)
        .where(i.accountId.eq(a.id))
        .orderBy(i.orderDate.desc())
        .limit(2)
);
Subquery y = sql.subquery("y",
    sql.select(p.paymentDate.as("lastPayment"))
        .from(p)
        .where(p.invoiceId.eq(a.id))
        .orderBy(p.paymentDate.desc())
        .limit(1)
);
List<Row> rows = sql.select()
    .from(a)
    .joinLateral(x)
    .leftJoinLateral(y)
    .where(a.branchId.eq(1014))
    .execute();
```

Lateral joins can be mixed up with any other types of joins in the same query. Some care needs to be taken to include them in the right order in the join sequence, so they produce the desired
results.

**Note**: Lateral joins should be correlated; otherwise they don't make sense. Some engines are
smart enough to detect non-correlated queries (PostgreSQL between them), so you may notice
they don't execute them in a lateral way even when you write them this way. This can be tricky for some queries
that use non-correlated functions (such as `rand()`) that you may want to use in a lateral way. If that's the case, you can trick the optimizer by adding a dummy extra predicate: for example, you can add `rand() + x.id * 0` so the optimizer considers there is correlation (`x.id` is included but has no side effect).


