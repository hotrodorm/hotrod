# LiveSQL Subqueries

Since its inception in version 3.0 LiveSQL has included a subset of the subqueries syntax for a
limited number of cases. Starting in version 4.1 LiveSQL now offers a full syntax that
covers most of the common and heavily syntax for subqueries.

## Overview

The implementation of SQL subqueries changes dramatically in version 4.1.

### LiveSQL 3.0

LiveSQL implements subqueries since version 3.0, although limited to a few specific cases. They are available for:

- **IN/NOT IN Operators**: These operators filter data by checking if a column, value or expression is included or excluded in a list
generated by a subquery.

- **EXISTS/NOT EXISTS Operators**: These operators filter data by checking if at least one row
(with any value or nulls) is generated by subquery. This subquery can be plain or correlated
to the main query.

- **Assymmetric Operators**: These operators filter data by comparing scalar values against sets of values generated by a subquery. This subquery
can be plain or correlated to the main query. Assymmetric operator combine the traditional operators `=`, `<>`, `<`, `>`, `<=`, `>=` by appending the extra clauses `ALL` or `ANY` to them.

### LiveSQL 4.1

The addition of the following types of subqueries greatly enhances the syntax of LiveSQL, to
produce powerful, complex queries.
It includes:

- **Scalar Subqueries**: Scalar Subqueries are embedded subqueries in the select list that return one column, and zero or one row. They
are typically used to produce values in the select list that are computed by a query that needs to access related
(or unrelated) tables.

- **Table Expressions**: The most common type of subqueries that include the full syntax for Table Expressions (also known as *Derived Tables* 
or *Inline Views*). They can be included in the `FROM` and `JOIN` clauses and also allow nesting of subqueries as
allowed by the SQL Standard.

- **Common Table Expressions (CTEs)**: Common Table Expressions greatly simplify the use and reuse of table expressions by naming them in advance, and using them later. Plain and recursive CTEs  are implemented.

- **Lateral Joins**: Inner and outer lateral joins are implemented. Since not all database engines support them LiveSQL limits its use to specific engines and specific versions of them. In short, LiveSQL support lateral joins for the following databases:
    - Oracle 12c1 or newer
    - DB2 LUW 10.5 or newer
    - PostgreSQL 9.3 or newer
    - SQL Server 2014 or newer
    - MySQL 8.0.14 or newer


## Examples

The following examples illustrate the different types of subqueries. Each one includes the LiveSQL code and the corresponding SQL query that is run in the database.

### 1. IN/NOT IN Operators

The following query uses the `NOT IN` operator:

```sql
SELECT *
FROM account
WHERE branch_id not in (
  SELECT id FROM branch WHERE region = 'SOUTH'
)
```

Using the method `.notIn(<subquery>)` it can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

ExecutableSelect<Row> q = sql.select()
    .from(a)
    .where(a.branchId.notIn(
        sql.select(b.id).from(b).where(b.region.eq("SOUTH"))
    ));
```

### 2. EXISTS/NOT EXISTS Operators

The following query uses the `NOT EXISTS` operator:

```sql
SELECT *
FROM account a
WHERE not exists (
  SELECT 1 FROM branch b WHERE b.id = a.branch_id and b.region = 'SOUTH'
)
```

Using the method `.notExists(<subquery>)` it can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

ExecutableSelect<Row> q = sql.select()
    .from(a)
    .where(sql.notExists( 
        sql.select(sql.val(1)).from(b).where(b.id.eq(a.branchId).and(b.region.eq("SOUTH"))) 
    ));
```

### 3. Assymmetric Operators

The following query uses the `> ANY` operator:

```sql
SELECT *
FROM invoice i
WHERE i.unpaid_balance > ANY (
  SELECT x.amount * 0.5 FROM invoice x WHERE x.account_id = i.account_id
)
```

Using the method `.gtAny(<subquery>)` it can be written in LiveSQL as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceTable x = InvoiceDAO.newTable("x");

ExecutableSelect<Row> q = sql.select() 
    .from(i) 
    .where(i.unpaidBalance.gtAny( 
        sql.select(x.amount.mult(0.5)).from(x).where(x.accountId.eq(i.accountId)) 
    ));
```

### 4. Scalar Subqueries

Scalar subqueries evaluate to a single *scalar* value. They can appear in any place where a number
can be included in the query; typically they are placed in the select list. The following query
includes two scalar subqueries:


```sql
select
  i.*,
  50 + (select max(amount) from payment where amount < 1000) / 2 as "score",
  (select max(b.status) from invoice b where b.account_id = i.account_id and b.id <> i.id)
    || '/C' as "maxStatus"
from invoice i
where i.status = 'UNPAID'

```

Using `sql.selectScalar()` the query can be written as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceTable b = InvoiceDAO.newTable("b");
PaymentTable p = PaymentDAO.newTable("p");

ExecutableSelect<Row> q = sql.select(
    i.star(),
    sql.val(50).plus(sql.selectScalar(sql.max(i.amount)).from(p).where(p.amount.lt(1000)).div(2)).as("score"),
    sql.selectScalar(sql.max(b.status)).from(b).where(b.accountId.eq(i.accountId).and(b.id.ne(i.id)))
      .concat("/C").as("maxStatus"))
  .from(i)
  .where(i.status.eq("UNPAID"));
```

**Notes**:

- The first scalar subquery takes the place of a number. As such it's divided by 2 and then it's added the value 50.
- The first scalar subquery is not correlated; the second one is, since its value depends on the main driving table.
- Depending on the parameter value, the type of the scalar subquery can be any of the six core types of LiveSQL. Namely: number, string, boolean, date/time, binary, and object. In this case the first one produces a number, and the second scalar subquery produces a string value.
- Finally, remember that a scalar subquery can only include a single column. It must generate zero or one rows at the most. If more rows are generated, the whole query will fail with an error.

### 5. Table Expressions

Table Expressions can take the place of a table or view in a query.

**Basic Table Expression**

The following query joins a table expression:

```sql
SELECT
  a.id as id,
  a.branch_id as "branchId",
  sum(l."lineTotal") as "total"
FROM public.account a
JOIN (
  SELECT
    i.account_id as "accountId",
    p.id as id,
    sum(l.line_total) as "lineTotal"
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.type = 'OTC'
  GROUP BY i.account_id, p.id
) x ON x."accountId" = a.id
WHERE x.total > 1000
```

The table expression `x` is defined in advanced, and the it takes the place of a traditional
table in the `from()` or `join()` clauses:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(i.accountId, p.id, sql.sum(l.lineTotal).as("total")) 
        .from(i) 
        .join(l, l.invoiceId.eq(i.id)) 
        .join(p, p.id.eq(l.productId)) 
        .where(p.type.eq("OTC")) 
        .groupBy(i.accountId, p.id) 
);
ExecutableSelect<Row> q = sql.select(a.star()) 
    .from(a) 
    .join(x, x.num("accountId").eq(a.id)) 
    .where(x.num("total").gt(1000));
```

**Nested Table Expressions**

*Pending*

**Joining Table Expressions**

Any number of table expressions can participate in a query. The following example
joins two tables expressions:

```sql
SELECT
  x."isVip",
  x.id,
  x."branchId"
FROM (
  SELECT
    b.is_vip as "isVip", 
    a.id as id, 
    a.branch_id as "branchId"
  FROM public.branch b
  JOIN public.account a ON a.branch_id = b.id
) x
LEFT JOIN (
  SELECT
    i.account_id as "accountId"
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.shipping = 0
) y ON y."accountId" = x.id
WHERE y."accountId" is null
```

It can be written in LiveSQL as:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(b.isVip, a.star()) 
        .from(b) 
        .join(a, a.branchId.eq(b.id)) 
);
Subquery y = sql.subquery("y", 
    sql.select(i.accountId) 
        .from(i) 
        .join(l, l.invoiceId.eq(i.id)) 
        .join(p, p.id.eq(l.productId)) 
        .where(p.shipping.eq(0)));
ExecutableSelect<Row> q = sql.select(x.star()) 
    .from(x) 
    .leftJoin(y, y.num("accountId").eq(x.num("id"))) 
    .where(y.num("accountId").isNull());
```

### 6. Common Table Expressions (CTEs)

Common Table Expressions are also supported. For example, the query above can also
be written with CTEs. It takes the form:

```sql
WITH
x as (
  SELECT
    b.is_vip as "isVip", 
    a.id as id, 
    a.branch_id as "branchId"
  FROM public.branch b
  JOIN public.account a ON a.branch_id = b.id
),
y (aid) as (
  SELECT
    i.account_id as "accountId"
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.shipping = 0
)
SELECT
  x."isVip", 
  x.id, 
  x."branchId"
FROM x
LEFT JOIN y ON y.aid = x.id
WHERE y.aid is null
```

It's written in LiveSQl as:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

CTE x = sql.cte("x", 
    sql.select(b.isVip, a.star()) 
        .from(b) 
        .join(a, a.branchId.eq(b.id)) 
);
CTE y = sql.cte("y").columnNames("aid").as(sql.select(i.accountId) 
    .from(i) 
    .join(l, l.invoiceId.eq(i.id)) 
    .join(p, p.id.eq(l.productId)) 
    .where(p.shipping.eq(0)));
ExecutableSelect<Row> q = sql.with(x, y) 
    .select(x.star()) 
    .from(x) 
    .leftJoin(y, y.num("aid").eq(x.num("id"))) 
    .where(y.num("aid").isNull());
```

### 7. Recursive Common Table Expressions (CTEs)

*Pending*

### 8. Lateral Joins

Lateral joins are executed once per each row of the previous tables or table
expression. Lateral joins can operate as inner or outer joins. 

The following example shows both types:

```sql
SELECT
  a.id as id, 
  a.branch_id as "branchId", 
  x."orderDate", 
  y."lastPayment"
FROM public.account a
JOIN LATERAL (
  SELECT
    i.order_date as "orderDate"
  FROM public.invoice i
  WHERE i.account_id = a.id
  ORDER BY i.order_date desc
  LIMIT 2
) x ON true
LEFT JOIN LATERAL (
  SELECT
    p.payment_date as "lastPayment"
  FROM public.payment p
  WHERE p.invoice_id = a.id
  ORDER BY p.payment_date desc
  LIMIT 1
) y ON true
WHERE a.branch_id = 1014
```

This query can be written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
PaymentTable p = PaymentDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(i.orderDate) 
        .from(i) 
        .where(i.accountId.eq(a.id)) 
        .orderBy(i.orderDate.desc()) 
        .limit(2) 
);
Subquery y = sql.subquery("y", 
    sql.select(p.paymentDate.as("lastPayment")) 
        .from(p) 
        .where(p.invoiceId.eq(a.id)) 
        .orderBy(p.paymentDate.desc()) 
        .limit(1) 
);
ExecutableSelect<Row> q = sql.select() 
    .from(a) 
    .joinLateral(x) 
    .leftJoinLateral(y) 
    .where(a.branchId.eq(1014));
```

