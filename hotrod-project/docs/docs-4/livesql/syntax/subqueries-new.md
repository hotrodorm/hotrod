# LiveSQL Subqueries

Since its inception in version 3.0 LiveSQL has included a subset of the subqueries syntax for a
limited number of cases. Starting in version 4.1 LiveSQL now offers a full syntax that
covers most of the common and heavily syntax for subqueries.

## Overview

### LiveSQL 3.0

LiveSQL implements subqueries since version 3.0, although limited to a few specific cases. They are available for:

- **IN/NOT IN Operators**: These operators filter data by checking if a column, value or expression is included or excluded in a list
generated by a subquery.

- **EXISTS/NOT EXISTS Operators**: These operators filter data by checking if at least one row
(with any value or nulls) is generated by subquery. This subquery can be plain or correlated
to the main query.

- **Assymmetric Operators**: These operators filter data by comparing scalar values against sets of values generated by a subquery. This subquery
can be plain or correlated to the main query. Assymmetric operator combine the traditional operators `=`, `<>`, `<`, `>`, `<=`, `>=` by appending the extra clauses `ALL` or `ANY` to them.

### LiveSQL 4.1

The addition of the following types of subqueries greatly enhances the syntax of LiveSQL, to
produce powerful, complex queries.
It includes:

- **Scalar Subqueries**: Scalar Subqueries are embedded subqueries in the select list that return one column, and zero or one row. They
are typically used to produce values in the select list that are computed by a query that needs to access related
(or unrelated) tables.

- **Table Expressions**: The most common type of subqueries that include the full syntax for Table Expressions (also known as *Derived Tables* 
or *Inline Views*). They can be included in the `FROM` and `JOIN` clauses and also allow nesting of subqueries as
allowed by the SQL Standard.

- **Common Table Expressions (CTEs)**: Common Table Expressions greatly simplify the use and reuse of table expressions by naming them in advance, and using them later. Plain and recursive CTEs  are implemented.

- **Lateral Joins**: Inner and outer lateral joins are implemented. Since not all database engine supports them LiveSQL limits its use to specific engines and specific versions of them. In short, LiveSQL support lateral joins for the following databases:
    - Oracle 12c1 or newer
    - DB2 LUW 10.5 or newer
    - PostgreSQL 9.3 or newer
    - SQL Server 2014 or newer
    - MySQL 8.0.14 or newer


## Examples

The following examples illustrate the different types of subqueries. Each one includes the LiveSQL code and the corresponding SQL query that is run in the database.

### 1. IN/NOT IN Operators

The `[NOT] IN` operator can written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

ExecutableSelect<Row> q = sql.select()
    .from(a)
    .where(a.branchId.notIn(
        sql.select(b.id).from(b).where(b.region.eq("SOUTH"))
    ));
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):

```sql
SELECT
  a.id as id,
  a.branch_id as "branchId"
FROM public.account a
WHERE a.branch_id not in (
  SELECT
    b.id as id
  FROM public.branch b
  WHERE b.region = #{p1}
)
--- Parameters ---
 * p1 (java.lang.String, length=5): SOUTH
------------------
```

### 2. EXISTS/NOT EXISTS Operators

The `[NOT] EXISTS` operator can written in LiveSQL as:

```java
AccountTable a = AccountDAO.newTable("a");
BranchTable b = BranchDAO.newTable("b");

ExecutableSelect<Row> q = sql.select()
    .from(a)
    .where(sql.notExists( 
        sql.select(sql.val(1)).from(b).where(b.id.eq(a.branchId).and(b.region.eq("SOUTH"))) 
    ));
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):

```sql
SELECT
  a.id as id, 
  a.branch_id as "branchId"
FROM public.account a
WHERE not exists (
  SELECT
    #{p1}
  FROM public.branch b
  WHERE b.id = a.branch_id and b.region = #{p2}
)
--- Parameters ---
 * p1 (java.lang.Integer): 1
 * p2 (java.lang.String, length=5): SOUTH
------------------
```

### 3. Assymmetric Operators

Assymmetric operators can written in LiveSQL as:

```java
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceTable x = InvoiceDAO.newTable("x");

ExecutableSelect<Row> q = sql.select() 
    .from(i) 
    .where(i.unpaidBalance.gtAny( 
        sql.select(x.amount.mult(0.5)).from(x).where(x.accountId.eq(i.accountId)) 
    ));
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):


```sql
SELECT
  i.id as id, 
  i.account_id as "accountId", 
  i.amount as amount, 
  i.order_date as "orderDate", 
  i.type as type, 
  i.unpaid_balance as "unpaidBalance", 
  i.status as status
FROM public.invoice i
WHERE i.unpaid_balance > any (
  SELECT
    x.amount * #{p1}
  FROM public.invoice x
  WHERE x.account_id = i.account_id
)
--- Parameters ---
 * p1 (java.lang.Double): 0.5
------------------
```

### 4. Scalar Subqueries

*Pending*

### 5. Table Expressions - Basic Example

LiveSQL uses the `Subquery` class to implement table expressions:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(i.accountId, p.id, sql.sum(l.lineTotal).as("total")) 
        .from(i) 
        .join(l, l.invoiceId.eq(i.id)) 
        .join(p, p.id.eq(l.productId)) 
        .where(p.type.eq("OTC")) 
        .groupBy(i.accountId, p.id) 
);
ExecutableSelect<Row> q = sql.select(a.star()) 
    .from(a) 
    .join(x, x.num("accountId").eq(a.id)) 
    .where(x.num("total").gt(1000));
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):


```sql
SELECT
  a.id as id, 
  a.branch_id as "branchId"
FROM public.account a
JOIN (
  SELECT
    i.account_id as "accountId", 
    p.id as id, 
    sum(l.line_total) as total
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.type = #{p1}
  GROUP BY i.account_id, p.id
) x ON x."accountId" = a.id
WHERE x.total > #{p2}
--- Parameters ---
 * p1 (java.lang.String, length=3): OTC
 * p2 (java.lang.Integer): 1000
------------------
```

### 6. Table Expressions - Nested Table Expressions

*Pending*

### 7. Table Expressions - Joining Table Expressions

Two or more table expressions can be joined following the syntax:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(b.isVip, a.star()) 
        .from(b) 
        .join(a, a.branchId.eq(b.id)) 
);
Subquery y = sql.subquery("y", 
    sql.select(i.accountId) 
        .from(i) 
        .join(l, l.invoiceId.eq(i.id)) 
        .join(p, p.id.eq(l.productId)) 
        .where(p.shipping.eq(0)));
ExecutableSelect<Row> q = sql.select(x.star()) 
    .from(x) 
    .leftJoin(y, y.num("accountId").eq(x.num("id"))) 
    .where(y.num("accountId").isNull());
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):


```sql
SELECT
  x."isVip", 
  x.id, 
  x."branchId"
FROM (
  SELECT
    b.is_vip as "isVip", 
    a.id as id, 
    a.branch_id as "branchId"
  FROM public.branch b
  JOIN public.account a ON a.branch_id = b.id
) x
LEFT JOIN (
  SELECT
    i.account_id as "accountId"
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.shipping = #{p1}
) y ON y."accountId" = x.id
WHERE y."accountId" is null
--- Parameters ---
 * p1 (java.lang.Integer): 0
------------------
```

### 8. Common Table Expressions (CTEs)

The previous example can also be written with CTEs, as in:

```java
BranchTable b = BranchDAO.newTable("b");
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
InvoiceLineTable l = InvoiceLineDAO.newTable("l");
ProductTable p = ProductDAO.newTable("p");

CTE x = sql.cte("x", 
    sql.select(b.isVip, a.star()) 
        .from(b) 
        .join(a, a.branchId.eq(b.id)) 
);
CTE y = sql.cte("y").columnNames("aid").as(sql.select(i.accountId) 
    .from(i) 
    .join(l, l.invoiceId.eq(i.id)) 
    .join(p, p.id.eq(l.productId)) 
    .where(p.shipping.eq(0)));
ExecutableSelect<Row> q = sql.with(x, y) 
    .select(x.star()) 
    .from(x) 
    .leftJoin(y, y.num("aid").eq(x.num("id"))) 
    .where(y.num("aid").isNull());
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):


```sql
WITH
x as (
  SELECT
    b.is_vip as "isVip", 
    a.id as id, 
    a.branch_id as "branchId"
  FROM public.branch b
  JOIN public.account a ON a.branch_id = b.id
),
y (aid) as (
  SELECT
    i.account_id as "accountId"
  FROM public.invoice i
  JOIN public.invoice_line l ON l.invoice_id = i.id
  JOIN public.product p ON p.id = l.product_id
  WHERE p.shipping = #{p1}
)
SELECT
  x."isVip", 
  x.id, 
  x."branchId"
FROM x
LEFT JOIN y ON y.aid = x.id
WHERE y.aid is null
--- Parameters ---
 * p1 (java.lang.Integer): 0
------------------
```

### 9. Recursive Common Table Expressions (CTEs)

*Pending*

### 10. Lateral Joins

Lateral joins &mdash; inner an outer ones &mdash; can be written as:

```java
AccountTable a = AccountDAO.newTable("a");
InvoiceTable i = InvoiceDAO.newTable("i");
PaymentTable p = PaymentDAO.newTable("p");

Subquery x = sql.subquery("x", 
    sql.select(i.orderDate) 
        .from(i) 
        .where(i.accountId.eq(a.id)) 
        .orderBy(i.orderDate.desc()) 
        .limit(2) 
);
Subquery y = sql.subquery("y", 
    sql.select(p.paymentDate.as("lastPayment")) 
        .from(p) 
        .where(p.invoiceId.eq(a.id)) 
        .orderBy(p.paymentDate.desc()) 
        .limit(1) 
);
ExecutableSelect<Row> q = sql.select() 
    .from(a) 
    .joinLateral(x) 
    .leftJoinLateral(y) 
    .where(a.branchId.eq(1014));
```

LiveSQL converts it behind the scenes to (in PostgreSQL's dialect):


```sql
SELECT
  a.id as id, 
  a.branch_id as "branchId", 
  x."orderDate", 
  y."lastPayment"
FROM public.account a
JOIN LATERAL (
  SELECT
    i.order_date as "orderDate"
  FROM public.invoice i
  WHERE i.account_id = a.id
  ORDER BY i.order_date desc
  LIMIT 2
) x ON true
LEFT JOIN LATERAL (
  SELECT
    p.payment_date as "lastPayment"
  FROM public.payment p
  WHERE p.invoice_id = a.id
  ORDER BY p.payment_date desc
  LIMIT 1
) y ON true
WHERE a.branch_id = #{p1}
--- Parameters ---
 * p1 (java.lang.Integer): 1014
------------------
```

