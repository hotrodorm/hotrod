# LiveSQL Subqueries

Since its inception in version 3.0 LiveSQL has included a subset of the subqueries syntax for specific use
cases. Starting in version 4.1 it now offers a full syntax that covers most of the SQL Standard syntax.

## Overview

### LiveSQL 3.0

This includes the original types of subqueries implemented since the initial version of LiveSQL.

#### IN/NOT IN Operators

These operators filter data by checking if a column, value or expression is included or excluded in a list
generated by a subquery.

#### EXISTS/NOT EXISTS Operators

These operators filter data by checking if at least one row (with any value or nulls) is generated by 
subquery. This subquery can be plain or correlated to the main query.

#### Assymmetric Operators

These operators filter data by comparing scalar values against sets of values generated by a subquery. This subquery
can be plain or correlated to the main query. Assymmetric operator combine the traditional operators `=`, `<>`, `<`, `>`, `<=`, `>=` 
by appending the extra clauses `ALL` or `ANY` to them.

### LiveSQL 4.1

Version 4.1 includes a comprehensive list of subqueries that covers most of the subqueries syntax and opens a wide 
range of possibilities for query execution.

#### Scalar Subqueries

Scalar Subqueries are embedded subqueries in the select list that return one value and at most one row. They
are typically used to produce values in the select list that are computed by a query that needs to access related
or unrelated tables.

#### Table Expressions

The most common type of subqueries that include the full syntax for Table Expressions (also known as *Derived Tables* 
or *Inline Views*). They can be included in the `FROM` and `JOIN` clauses and also allow nesting of subqueries as
allowed by the SQL Standard.

#### Common Table Expressions (CTEs)

Both types of Common Table Expressions, plain and recursive, are implemented.

#### Lateral Joins

Inner and outer lateral joins are implemented. Lateral joins support is only available in the databases that support them

LiveSQL support lateral joins in the following databases:

- Oracle 12c1 or newer
- DB2 10.5 or newer
- PostgreSQL 9.3 or newer
- SQL Server 2014 or newer
- MySQL 8.0.14 or newer
 
## Examples


## Using a Subquery in the IN Operator

The following query uses a subquery in the `IN` operator:

```java
EmployeeTable e = EmployeeDAO.newTable("e");
CodesTable c = CodesDAO.newTable("c");

List<Row> rows = this.sql 
    .select()
    .from(e) 
    .where(e.type.notIn(
      this.sql.select(c.type).from(c).where(c.active.eq(1))
    ))
    .execute();
```

The resulting query is:

```sql
SELECT *
FROM employee e
WHERE e.type NOT IN (
  select c.type from codes c where c.active = 1
)
```

## Using a Subquery in the EXISTS Operator

The following query uses a subquery in the `EXISTS` operator. This query is equivalent
to the query above. [^1]

```java
EmployeeTable e = EmployeeDAO.newTable("e");
CodesTable c = CodesDAO.newTable("c");

List<Row> rows = this.sql 
    .select()
    .from(e) 
    .where(this.sql.notExists(
      this.sql.select().from(c).where(c.active.eq(1).and(c.type.eq.e.type))
    ))
    .execute();
```

The resulting query is:

```sql
SELECT *
FROM employee e
WHERE NOT EXISTS (
  select * from codes c where c.active = 1 and c.type = e.type
)
```

[^1]: This query is equivalent to the query above most of the time. In the presence of nulls, however, if may
produce a different result set.


## Tuples

Tuples are implemented using `sql.tuple(<expressions>)` and can be useful for the `IN` operator when 
comparing more than one column. For example:

```java
EmployeeTable e = EmployeeDAO.newTable("e");
CodesTable c = CodesDAO.newTable("c");

List<Row> rows = this.sql 
    .select()
    .from(e) 
    .where(e.tuple(e.type, e.region).notIn(
      this.sql.select(c.type, c.region).from(c).where(c.active.eq(1))
    ))
    .execute();
```

The resulting query is:

```sql
SELECT *
FROM employee e
WHERE (e.type, e.region) NOT IN (
  select c.type, c.region from codes c where c.active = 1
)
```